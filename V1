import tkinter as tk
from tkinter import ttk, messagebox, filedialog, colorchooser, simpledialog
from typing import Set, Tuple, List, Dict, Union, Optional, Deque
from dataclasses import dataclass, field
from collections import Counter, OrderedDict, deque
import random

from openpyxl import Workbook, load_workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side, Font
from openpyxl.utils import get_column_letter

# --------------------------------
# Types & Models
# --------------------------------
Cell = Tuple[int, int]  # (row, col) 1-based

@dataclass
class Block:
    rows: int
    cols: int
    hatch: str = ""
    hold: str = ""
    bay: str = ""
    deck: str = ""
    cell_colors: Dict[Cell, str] = field(default_factory=dict)
    cell_numbers: Dict[Cell, Union[int, float, str]] = field(default_factory=dict)
    sockets: Set[Cell] = field(default_factory=set)
    gang_counts: Dict[int, int] = field(default_factory=dict)

@dataclass
class SectionHeader:
    title: str

Item = Union[Block, SectionHeader]

# --------------------------------
# Utils
# --------------------------------
def parse_number_like(s: str) -> Union[int, float, str]:
    try:
        s_strip = str(s).strip()
        if not s_strip: return ""
        if "." in s_strip:
            f = float(s_strip)
            return int(f) if f.is_integer() else f
        return int(s_strip)
    except (ValueError, TypeError):
        return s

def header_sequence(n: int) -> List[int]:
    evens = [x for x in range(n, 0, -1) if x % 2 == 0]
    odds = list(range(1, n + 1, 2))
    return evens + odds

def set_range_border(ws, min_row, max_row, min_col, max_col, side_top, side_right, side_bottom, side_left):
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            cell = ws.cell(row=r, column=c)
            current_border = cell.border
            new_border = Border(
                top=side_top if r == min_row else current_border.top,
                bottom=side_bottom if r == max_row else current_border.bottom,
                left=side_left if c == min_col else current_border.left,
                right=side_right if c == max_col else current_border.right
            )
            cell.border = new_border

def thick_column_positions(max_grid_cols: int) -> List[int]:
    if max_grid_cols <= 0: return []
    seq = header_sequence(max_grid_cols)
    try:
        boundary_col = seq.index(1) + 1
    except ValueError:
        return []
    pos = {x for x in range(boundary_col, max_grid_cols + 1, 4)}
    pos.update({x for x in range(boundary_col - 4, 0, -4)})
    return sorted(list(pos))

def safe_sheet_title(s: str) -> str:
    invalid_chars = r'[]:*?/\ '
    clean_s = "".join(c if c not in invalid_chars else '-' for c in (s or "Sheet"))
    return clean_s[:31]

# --------------------------------
# Excel Writer
# --------------------------------
def write_excel(
    items: List[Item],
    filename: str,
    ship_no: str,
    looking_text: str = "LOOKING TO FWD",
    row_gap_between_blocks: int = 2,
    info_cols: int = 1, gap_after_info: int = 1,
    deck_cols: int = 1, gap_after_deck: int = 1
):
    if not items:
        raise ValueError("No content to export. Add blocks or section headers.")

    block_cols = [it.cols for it in items if isinstance(it, Block)]
    max_grid_cols = max(block_cols) if block_cols else 6

    grid_start_col = info_cols + gap_after_info + deck_cols + gap_after_deck + 1
    grid_right_col = grid_start_col + max_grid_cols - 1

    qty_col = grid_right_col + 3
    gang_gap_col = qty_col + 1
    g_start_col = qty_col + 2
    g_cols = {g: g_start_col + (g - 3) for g in range(3, 10)}
    g_sum_col = g_start_col + 7

    wb = Workbook()
    ws = wb.active
    ws.title = safe_sheet_title(ship_no)

    align_center = Alignment(horizontal="center", vertical="center")
    align_right  = Alignment(horizontal="right",  vertical="center")
    thin  = Side(style="thin", color="000000")
    thick = Side(style="thick", color="000000")
    dashed_med = Side(style="mediumDashed", color="000000")
    border_thin  = Border(left=thin, right=thin, top=thin, bottom=thin)
    gray_fill = PatternFill("solid", fgColor="EEEEEE")

    for c in range(1, g_sum_col + 2): ws.column_dimensions[get_column_letter(c)].width = 4
    for c in range(1, info_cols + 1): ws.column_dimensions[get_column_letter(c)].width = 10
    ws.column_dimensions[get_column_letter(info_cols + 1)].width = 2
    for c in range(info_cols + 2, info_cols + 2 + deck_cols): ws.column_dimensions[get_column_letter(c)].width = 4
    ws.column_dimensions[get_column_letter(info_cols + 2 + deck_cols)].width = 2

    from openpyxl.utils import get_column_letter as _g
    ws.column_dimensions[_g(qty_col - 2)].width = 4
    ws.column_dimensions[_g(qty_col - 1)].width = 5
    ws.column_dimensions[_g(qty_col)].width     = 4
    ws.column_dimensions[_g(gang_gap_col)].width= 2
    for g in range(3, 10): ws.column_dimensions[_g(g_cols[g])].width = 4
    ws.column_dimensions[_g(g_sum_col)].width   = 7

    title_text = (ship_no.strip() + " Reefer Arrangement") if ship_no.strip() else "Reefer Arrangement"
    try:
        ws.oddHeader.center.text = f"&B&11{title_text}"
        ws.oddHeader.right.text  = f"&B&11{(looking_text or 'LOOKING TO FWD')}"
    except Exception:
        pass

    left_end = max(1, grid_right_col - 4)
    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=left_end)
    tcell = ws.cell(row=1, column=1, value=title_text)
    tcell.alignment = align_center; tcell.font = Font(size=11, bold=True)
    set_range_border(ws, 1, 1, 1, left_end, thick, thick, thick, thick)

    right_start = left_end + 1
    ws.merge_cells(start_row=1, start_column=right_start, end_row=1, end_column=grid_right_col)
    rcell = ws.cell(row=1, column=right_start, value=(looking_text or "LOOKING TO FWD"))
    rcell.alignment = align_center; rcell.font = Font(size=10)
    set_range_border(ws, 1, 1, right_start, grid_right_col, thick, thick, thick, thick)

    cur_row = 3

    seq = header_sequence(max_grid_cols)
    for i, val in enumerate(seq, start=0):
        cc = grid_start_col + i
        ws.cell(row=cur_row, column=cc, value=int(val)).alignment = align_center
        ws.cell(row=cur_row, column=cc).font = Font(size=9, bold=True)

    ws.merge_cells(start_row=cur_row+1, start_column=g_cols[3], end_row=cur_row+1, end_column=g_sum_col)
    gtitle = ws.cell(row=cur_row+1, column=g_cols[3], value="gang별 수량")
    gtitle.alignment = align_center; gtitle.font = Font(size=9, bold=True)
    for c in range(g_cols[3], g_sum_col + 1):
        ws.cell(row=cur_row+1, column=c).fill = gray_fill

    hrow = cur_row + 2
    ws.cell(row=hrow, column=qty_col, value="Q'ty").alignment = align_center
    for g in range(3, 10):
        hc = ws.cell(row=hrow, column=g_cols[g], value=g)
        hc.alignment = align_center; hc.fill = gray_fill
    sm = ws.cell(row=hrow, column=g_sum_col, value="SUM")
    sm.alignment = align_center; sm.fill = gray_fill

    cur_row = hrow + 1
    vertical_thick_cols = set(thick_column_positions(max_grid_cols))
    last_used_row = cur_row
    grand_qty_ranges = []
    gang_summary_rows = []

    count_left_letter  = get_column_letter(grid_start_col)
    count_right_letter = get_column_letter(grid_start_col + max_grid_cols - 1)

    for it in items:
        if isinstance(it, SectionHeader):
            ws.merge_cells(start_row=cur_row, start_column=grid_start_col, end_row=cur_row, end_column=grid_right_col)
            scell = ws.cell(row=cur_row, column=grid_start_col, value=it.title)
            scell.alignment = align_center; scell.font = Font(size=24, bold=True)
            set_range_border(ws, cur_row, cur_row, grid_start_col, grid_right_col, dashed_med, dashed_med, dashed_med, dashed_med)
            cur_row += 4; last_used_row = max(last_used_row, cur_row - 1)
            continue

        b: Block = it
        label_text = f"Hatch No. {b.hatch}" if b.hatch else (f"Hold No. {b.hold}" if b.hold else " ")
        ws.cell(row=cur_row, column=1, value=label_text).alignment = align_center
        ws.cell(row=cur_row, column=1).font = Font(size=8, color="C00000")
        set_range_border(ws, cur_row, cur_row, 1, 1, thin, thin, thin, thin)

        bay_text = f"Bay {b.bay}" if b.bay else " "
        ws.cell(row=cur_row + 1, column=1, value=bay_text).alignment = align_center
        ws.cell(row=cur_row + 1, column=1).font = Font(size=8, color="C00000")
        set_range_border(ws, cur_row + 1, cur_row + 1, 1, 1, thin, thin, thin, thin)

        deck_text = b.deck if b.deck else " "
        ws.cell(row=cur_row, column=info_cols + gap_after_info + 1, value=deck_text).alignment = align_center
        ws.cell(row=cur_row, column=info_cols + gap_after_info + 1).font = Font(size=8, color="C00000")

        left_offset = (max_grid_cols - b.cols) // 2
        block_start_row = cur_row
        block_end_row   = cur_row + b.rows - 1
        grand_qty_ranges.append((block_start_row, block_end_row))

        for r in range(1, b.rows + 1):
            rr = cur_row + r - 1
            ws.row_dimensions[rr].height = 20
            for c in range(1, b.cols + 1):
                global_grid_col = left_offset + c
                cc = grid_start_col + global_grid_col - 1
                cell = ws.cell(row=rr, column=cc)
                cell.alignment = align_center
                if (r,c) in b.cell_colors: cell.fill = PatternFill("solid", fgColor=b.cell_colors[(r,c)].lstrip("#"))
                cell.border = border_thin
                if (r,c) in b.cell_numbers: cell.value = parse_number_like(b.cell_numbers[(r,c)])
                if (r,c) in b.sockets: cell.border = Border(left=Side(style="thick", color="FF0000"), right=Side(style="thick", color="FF0000"), top=Side(style="thick", color="FF0000"), bottom=Side(style="thick", color="FF0000"))
                if global_grid_col in vertical_thick_cols: cell.border = Border(left=thick, right=cell.border.right, top=cell.border.top, bottom=cell.border.bottom)
            
            ws.cell(row=rr, column=qty_col, value=f"=COUNT({count_left_letter}{rr}:{count_right_letter}{rr})").alignment = align_center
            ws.cell(row=rr, column=qty_col).font = Font(size=8)
            ws.cell(row=rr, column=gang_gap_col).fill = gray_fill
            for g in range(3, 10): ws.cell(row=rr, column=g_cols[g]).fill = gray_fill
            ws.cell(row=rr, column=g_sum_col).fill = gray_fill

        sum_row = block_end_row + 1
        gang_summary_rows.append(sum_row)
        qcol_letter = get_column_letter(qty_col)
        total_cell = ws.cell(row=sum_row, column=qty_col, value=f"=SUM({qcol_letter}{block_start_row}:{qcol_letter}{block_end_row})")
        total_cell.alignment = align_center; total_cell.font = Font(size=8, bold=True)
        total_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)

        ws.cell(row=sum_row, column=gang_gap_col).fill = gray_fill
        terms = []
        for g in range(3, 10):
            cnt = int(b.gang_counts.get(g, 0) or 0)
            cell = ws.cell(row=sum_row, column=g_cols[g], value=cnt)
            cell.alignment = align_center; cell.font = Font(size=8); cell.fill = gray_fill
            terms.append(f"{g}*{get_column_letter(g_cols[g])}{sum_row}")
        
        gsum_cell = ws.cell(row=sum_row, column=g_sum_col, value="=" + "+".join(terms))
        gsum_cell.alignment = align_center; gsum_cell.font = Font(size=8, bold=True); gsum_cell.fill = gray_fill

        cur_row += max(b.rows, 2) + row_gap_between_blocks
        last_used_row = max(last_used_row, cur_row - 1)

    grand_row = last_used_row + 2
    ws.cell(row=grand_row, column=(qty_col - 1), value="Total").alignment = align_right; ws.cell(row=grand_row, column=(qty_col-1)).font = Font(size=9, bold=True)
    parts = [f"{get_column_letter(qty_col)}{s}:{get_column_letter(qty_col)}{e}" for s, e in grand_qty_ranges]
    grand_qty_cell = ws.cell(row=grand_row, column=qty_col, value=f"=SUM({','.join(parts)})")
    grand_qty_cell.alignment = align_center; grand_qty_cell.font = Font(size=9, bold=True)
    grand_qty_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)
    
    # --- Total Gang Counts Footer ---
    gang_total_row = grand_row + 2
    ws.cell(row=gang_total_row, column=g_cols[3]-2, value="Total Gangs:").alignment = align_right
    ws.cell(row=gang_total_row, column=g_cols[3]-2).font = Font(bold=True)
    for g in range(3, 10):
        col_letter = get_column_letter(g_cols[g])
        sum_parts = [f"{col_letter}{r}" for r in gang_summary_rows]
        cell = ws.cell(row=gang_total_row, column=g_cols[g], value=f"=SUM({','.join(sum_parts)})")
        cell.alignment = align_center; cell.font = Font(bold=True); cell.border = Border(top=thick, bottom=thick)

    for gcol in vertical_thick_cols:
        col_idx = grid_start_col + gcol - 1
        for r in range(3, last_used_row + 1):
            cell = ws.cell(row=r, column=col_idx)
            cell.border = Border(left=thick, right=cell.border.right, top=cell.border.top, bottom=cell.border.bottom)
    
    wb.save(filename)


class GridCanvas(ttk.Frame):
    def __init__(self, master):
        super().__init__(master, padding=10)
        self.pack(fill="both", expand=True)
        
        self.rows, self.cols, self.cell_px = 4, 20, 22
        self.cell_colors, self.cell_numbers, self.sockets = {}, {}, set()
        self.paint_mode = tk.StringVar(value="ADD COLOR")
        self.current_label = tk.StringVar(value="1")
        self.current_color = tk.StringVar(value="#87CEFA")
        self.ship_no = tk.StringVar(value="")
        self.looking_txt = tk.StringVar(value="LOOKING TO FWD")
        self.rs_count = tk.StringVar(value="8")
        self.rd_per_rs = tk.StringVar(value="12")
        self.gang_vars = {g: tk.StringVar(value="0") for g in range(3, 10)}
        self.items: List[Item] = []
        self.editing_index: Optional[int] = None
        self.drag_start, self.drag_rect_id = None, None
        self.drag_start_right, self.drag_rect_id_right = None, None
        self.insert_pos = tk.StringVar(value="1")

        self.rs_count.trace_add("write", self._recompute_all)
        self.rd_per_rs.trace_add("write", self._recompute_all)

        self._create_widgets()
        self.draw_all()
        self._recompute_all()
        self._update_insert_spin_range()

    def _create_widgets(self):
        outer = ttk.Frame(self); outer.pack(fill="both", expand=True)
        right = ttk.Frame(outer); right.pack(side="right", fill="both", padx=(10, 0))
        left = ttk.Frame(outer); left.pack(side="left", fill="both", expand=True)
        
        cfg = ttk.LabelFrame(right, text="RS / RD Panels", padding=10)
        cfg.pack(fill="x", pady=(0, 10))
        ttk.Label(cfg, text="RS Panels").grid(row=0, column=0, sticky="e", padx=5, pady=2)
        ttk.Spinbox(cfg, from_=0, to=999, textvariable=self.rs_count, width=8).grid(row=0, column=1, sticky="w", pady=2)
        ttk.Label(cfg, text="RD per RS").grid(row=0, column=2, sticky="e", padx=5, pady=2)
        ttk.Spinbox(cfg, from_=0, to=999, textvariable=self.rd_per_rs, width=8).grid(row=0, column=3, sticky="w", pady=2)

        ttk.Label(right, text="Live Summary").pack(anchor="w")
        alloc = ttk.Frame(right); alloc.pack(fill="both", expand=True)
        left_col = ttk.Frame(alloc); left_col.pack(side="left", fill="both", expand=True, padx=(0,5))
        ttk.Label(left_col, text="PORT RS (Even)").pack(anchor="w")
        self.txt_even = tk.Text(left_col, width=34, height=34, font=("Consolas", 10)); self.txt_even.pack(fill="both", expand=True); self.txt_even.configure(state="disabled")
        right_col = ttk.Frame(alloc); right_col.pack(side="left", fill="both", expand=True, padx=(5,0))
        ttk.Label(right_col, text="STBD RS (Odd)").pack(anchor="w")
        self.txt_odd = tk.Text(right_col, width=34, height=34, font=("Consolas", 10)); self.txt_odd.pack(fill="both", expand=True); self.txt_odd.configure(state="disabled")

        top = ttk.Frame(left); top.pack(fill="x", pady=(0, 10))
        ttk.Label(top, text="Ship No.").grid(row=0, column=0, padx=(4,4), pady=2, sticky="e")
        ttk.Entry(top, textvariable=self.ship_no, width=14).grid(row=0, column=1, padx=(0,12), pady=2)
        ttk.Label(top, text="Header Right").grid(row=0, column=2, padx=(4,4), pady=2, sticky="e")
        ttk.Entry(top, textvariable=self.looking_txt, width=18).grid(row=0, column=3, padx=(0,12), pady=2)
        ttk.Label(top, text="Mode").grid(row=1, column=0, padx=(4,4), pady=2, sticky="e")
        self.cmb_mode = ttk.Combobox(top, textvariable=self.paint_mode, values=("ADD COLOR", "ADD NUMBER", "ERASER", "SOCKET"), width=12, state="readonly")
        self.cmb_mode.grid(row=1, column=1, padx=(0,12), pady=2)
        ttk.Label(top, text="Number").grid(row=1, column=2, padx=(4,4), pady=2, sticky="e")
        ttk.Entry(top, textvariable=self.current_label, width=10).grid(row=1, column=3, padx=(0,12), pady=2)
        ttk.Label(top, text="Color").grid(row=1, column=4, padx=(4,4), pady=2, sticky="e")
        self.color_preview = tk.Label(top, text="   ", bg=self.current_color.get(), relief="groove", width=4)
        self.color_preview.grid(row=1, column=5, padx=(0,4), pady=2, sticky="w")
        ttk.Button(top, text="Pick…", command=self.pick_color).grid(row=1, column=6, padx=(2,12), pady=2)

        btn_row = ttk.Frame(left); btn_row.pack(fill="x", pady=5)
        ttk.Button(btn_row, text="Import Excel…", command=self.import_from_excel).grid(row=0, column=0, padx=4, pady=2)
        ttk.Button(btn_row, text="Edit Selected", command=self.edit_selected).grid(row=0, column=1, padx=4, pady=2)
        ttk.Button(btn_row, text="Save Edits", command=self.save_edits).grid(row=0, column=2, padx=4, pady=2)
        ttk.Button(btn_row, text="Delete Selected", command=self.delete_selected).grid(row=0, column=3, padx=4, pady=2)
        ttk.Button(btn_row, text="Auto Set", command=self.auto_set_groups).grid(row=0, column=4, padx=(12,4), pady=2)
        ttk.Button(btn_row, text="Export Excel…", command=self.export_excel).grid(row=0, column=5, padx=(12,4), pady=2)
        
        self.canvas = tk.Canvas(left, bg="white", highlightthickness=1, highlightbackground="#cccccc")
        self.canvas.pack(fill="both", expand=True, pady=5)
        self.canvas.bind("<Button-1>", self.on_press); self.canvas.bind("<B1-Motion>", self.on_drag); self.canvas.bind("<ButtonRelease-1>", self.on_release)
        self.canvas.bind("<Button-3>", self.on_press_right); self.canvas.bind("<B3-Motion>", self.on_drag_right); self.canvas.bind("<ButtonRelease-3>", self.on_release_right)
        self.canvas.bind("<Control-Button-1>", self.on_press_right); self.canvas.bind("<Control-B1-Motion>", self.on_drag_right); self.canvas.bind("<Control-ButtonRelease-1>", self.on_release_right)

        gang_row = ttk.Frame(left); gang_row.pack(fill="x", pady=5)
        ttk.Label(gang_row, text="Gang per Block").grid(row=0, column=0, padx=(4,8), pady=2, sticky="e")
        col = 1
        for g in range(3, 10):
            ttk.Label(gang_row, text=f"{g}").grid(row=0, column=col, padx=(4,2), pady=2, sticky="e")
            ttk.Entry(gang_row, textvariable=self.gang_vars[g], width=5).grid(row=0, column=col+1, padx=(0,8), pady=2)
            col += 2
        
        bottom = ttk.Frame(left); bottom.pack(fill="x", pady=5)
        ttk.Label(bottom, text="Items (Blocks / Sections)").pack(anchor="w")
        self.items_list = tk.Listbox(bottom, height=8); self.items_list.pack(fill="x", expand=True)
        self.items_list.bind("<Double-Button-1>", lambda e: self.edit_selected())
        
        meta = ttk.LabelFrame(left, text="Block Meta", padding=10)
        meta.pack(fill="x", pady=5)
        self.meta_label_type = tk.StringVar(value="Hatch No")
        ttk.Label(meta, text="Label Type").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        ttk.Combobox(meta, textvariable=self.meta_label_type, values=["Hatch No", "Hold No"], width=10, state="readonly").grid(row=0, column=1, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="No.").grid(row=0, column=2, sticky="e", padx=8, pady=2)
        self.meta_no = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_no, width=10).grid(row=0, column=3, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="Bay").grid(row=1, column=0, sticky="e", padx=4, pady=2)
        self.meta_bay = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_bay, width=10).grid(row=1, column=1, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="Deck").grid(row=1, column=2, sticky="e", padx=8, pady=2)
        self.meta_deck = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_deck, width=12).grid(row=1, column=3, sticky="w", padx=4, pady=2)
        ttk.Button(meta, text="Apply to Selected", command=self.apply_meta_to_selected).grid(row=0, column=4, rowspan=2, sticky="nsw", padx=(12,4), pady=2)

        sec = ttk.LabelFrame(left, text="Insert Section", padding=10)
        sec.pack(fill="x", pady=5)
        ttk.Label(sec, text="삽입 위치(1-기준)").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        self.pos_spin = ttk.Spinbox(sec, from_=1, to=1, textvariable=self.insert_pos, width=6)
        self.pos_spin.grid(row=0, column=1, sticky="w", padx=4, pady=2)
        ttk.Button(sec, text="Insert ACCOMMODATION", command=lambda: self.insert_section_at("ACCOMMODATION")).grid(row=0, column=2, padx=(12,4), pady=2)
        ttk.Button(sec, text="Insert E/R CASING", command=lambda: self.insert_section_at("E/R CASING")).grid(row=0, column=3, padx=4, pady=2)
    
    def _recompute_all(self, *args): self._update_allocation_display()
    def _rd_list_for_rs(self, rs_index, rd_per_rs):
        if rd_per_rs <= 0 or rs_index <= 0: return []
        if rs_index % 2 == 1:
            block_idx = (rs_index - 1) // 2; start_odd = 1 + 2 * (block_idx * rd_per_rs)
            return [start_odd + 2*i for i in range(rd_per_rs)]
        else:
            block_idx = (rs_index // 2) - 1; start_even = 2 + 2 * (block_idx * rd_per_rs)
            return [start_even + 2*i for i in range(rd_per_rs)]
    def _build_rd_queues(self):
        try: rs_total, rpr = int(self.rs_count.get() or 0), int(self.rd_per_rs.get() or 0)
        except(ValueError, TypeError): return [],[]
        even_q, odd_q = [], []
        for rs in range(1, rs_total + 1):
            (even_q if rs % 2 == 0 else odd_q).extend(self._rd_list_for_rs(rs, rpr))
        return sorted(list(set(even_q))), sorted(list(set(odd_q)))
    def _collect_rd_counts(self):
        c = Counter(int(v) for it in self.items if isinstance(it,Block) for v in it.cell_numbers.values() if str(v).strip())
        return OrderedDict(sorted(c.items()))
    def _build_rs_summary(self, rs_indices, rd_counts):
        try: rpr = int(self.rd_per_rs.get() or 0)
        except(ValueError, TypeError): rpr = 0
        lines = []
        for rs in rs_indices:
            rd_list = self._rd_list_for_rs(rs, rpr)
            total = sum(rd_counts.get(rd, 0) for rd in rd_list)
            lines.append(f"RS-{rs}: total {total}")
            lines.extend([f"  RD-{rd}: {rd_counts[rd]}" for rd in rd_list if rd_counts.get(rd, 0) > 0])
            if not any(rd_counts.get(rd, 0) > 0 for rd in rd_list): lines.append("  -")
            lines.append("")
        return "\n".join(lines).rstrip()
    def _update_allocation_display(self):
        try: rs_total = int(self.rs_count.get() or 0)
        except(ValueError, TypeError): rs_total=0
        even_rs = [i for i in range(1, rs_total+1) if i % 2 == 0]
        odd_rs  = [i for i in range(1, rs_total+1) if i % 2 == 1]
        rd_counts = self._collect_rd_counts()
        for txt_widget, indices in [(self.txt_even, even_rs), (self.txt_odd, odd_rs)]:
            content = self._build_rs_summary(indices, rd_counts)
            txt_widget.config(state="normal"); txt_widget.delete("1.0", tk.END); txt_widget.insert(tk.END, content); txt_widget.config(state="disabled")
    def pick_color(self):
        _, hx = colorchooser.askcolor(color=self.current_color.get(), title="Pick Color")
        if hx: self.current_color.set(hx); self.color_preview.config(bg=hx)
    def clear_canvas(self): self.cell_colors.clear(); self.cell_numbers.clear(); self.sockets.clear(); self.draw_all()
    def cell_to_xy(self, r, c): x1=(c-1)*self.cell_px+1; y1=(r-1)*self.cell_px+1; return x1,y1,x1+self.cell_px-1,y1+self.cell_px-1
    def xy_to_cell(self,x,y):
        c,r = int((x-1)//self.cell_px)+1, int((y-1)//self.cell_px)+1
        return (r,c) if 1<=r<=self.rows and 1<=c<=self.cols else None
    def draw_all(self):
        self.canvas.delete("all"); self.canvas.config(width=self.cols*self.cell_px+2, height=self.rows*self.cell_px+2)
        for r in range(1,self.rows+1):
            for c in range(1,self.cols+1):
                x1,y1,x2,y2 = self.cell_to_xy(r,c)
                self.canvas.create_rectangle(x1,y1,x2,y2,fill=self.cell_colors.get((r,c),"#FFFFFF"),outline="#CCCCCC")
        for r,c in self.sockets: x1,y1,x2,y2=self.cell_to_xy(r,c); self.canvas.create_rectangle(x1+1,y1+1,x2-1,y2-1,outline="#FF0000",width=2)
        for (r,c),val in self.cell_numbers.items(): x,y=(c-0.5)*self.cell_px,(r-0.5)*self.cell_px; self.canvas.create_text(x,y,text=str(val),font=("Arial",8))
    def on_press(self,e): self.drag_start = self.xy_to_cell(e.x,e.y); self.update_drag_rect(e, left_click=True)
    def on_drag(self,e): self.update_drag_rect(e, left_click=True)
    def on_release(self,e):
        if self.drag_rect_id: self.canvas.delete(self.drag_rect_id); self.drag_rect_id=None
        if not self.drag_start: return
        end_cell=self.xy_to_cell(e.x,e.y) or self.drag_start
        r1,c1=self.drag_start; r2,c2=end_cell
        mode=self.paint_mode.get()
        for r in range(min(r1,r2),max(r1,r2)+1):
            for c in range(min(c1,c2),max(c1,c2)+1):
                pos=(r,c)
                if mode=="ADD COLOR": self.cell_colors[pos]=self.current_color.get()
                elif mode=="ADD NUMBER": self.cell_numbers[pos]=parse_number_like(self.current_label.get())
                elif mode=="ERASER": self.cell_colors.pop(pos,None); self.cell_numbers.pop(pos,None); self.sockets.discard(pos)
                elif mode=="SOCKET": self.sockets.add(pos)
        self.drag_start=None; self.draw_all(); self._recompute_all()
    def on_press_right(self,e): self.drag_start_right = self.xy_to_cell(e.x,e.y); self.update_drag_rect(e, left_click=False)
    def on_drag_right(self,e): self.update_drag_rect(e, left_click=False)
    def on_release_right(self,e):
        if self.drag_rect_id_right: self.canvas.delete(self.drag_rect_id_right); self.drag_rect_id_right=None
        if not self.drag_start_right: return
        end_cell=self.xy_to_cell(e.x,e.y) or self.drag_start_right
        r1,c1=self.drag_start_right; r2,c2=end_cell
        for r in range(min(r1,r2),max(r1,r2)+1):
            for c in range(min(c1,c2),max(c1,c2)+1):
                pos=(r,c); mode=self.paint_mode.get()
                if mode=="ADD COLOR": self.cell_colors.pop(pos,None)
                elif mode=="ADD NUMBER": self.cell_numbers.pop(pos,None)
                elif mode=="SOCKET": self.sockets.discard(pos)
        self.drag_start_right=None; self.draw_all(); self._recompute_all()
    def update_drag_rect(self,e, left_click=True):
        start=self.drag_start if left_click else self.drag_start_right;
        if not start: return
        cell=self.xy_to_cell(e.x,e.y)
        if not cell: return
        rect_id=self.drag_rect_id if left_click else self.drag_rect_id_right
        if rect_id: self.canvas.delete(rect_id)
        r1,c1=start; r2,c2=cell
        x1,y1,_,_=self.cell_to_xy(min(r1,r2),min(c1,c2)); _,_,x2,y2=self.cell_to_xy(max(r1,r2),max(c1,c2))
        x2+=self.cell_px-1; y2+=self.cell_px-1
        outline_color = "#3B82F6" if left_click else "#EF4444"
        new_rect_id = self.canvas.create_rectangle(x1,y1,x2,y2,outline=outline_color,width=2, dash=(4,2))
        if left_click: self.drag_rect_id=new_rect_id
        else: self.drag_rect_id_right=new_rect_id
    def refresh_list(self):
        sel=self.items_list.curselection(); self.items_list.delete(0,tk.END)
        for i,it in enumerate(self.items,1): self.items_list.insert(tk.END, self.item_label(it,i))
        if sel: self.items_list.selection_set(sel[0])
        self._update_insert_spin_range(); self._recompute_all()
    def _update_insert_spin_range(self):
        total=len(self.items)+1; self.pos_spin.config(to=total)
        sel=self.items_list.curselection(); self.insert_pos.set(str(sel[0]+1 if sel else total))
    def item_label(self,it,idx):
        if isinstance(it,SectionHeader): return f"[Section] {it.title}"
        b:Block=it; label=f"Hatch:{b.hatch}" if b.hatch else (f"Hold:{b.hold}" if b.hold else "-")
        return f"Block {idx} — {b.rows}x{b.cols} | {label} Bay:{b.bay or '-'} Deck:{b.deck or '-'} | Nums:{len(b.cell_numbers)}"
    def _write_gang_counts(self,counts):
        for g in range(3,10): self.gang_vars[g].set(str(counts.get(g,0)))
    def edit_selected(self):
        sel=self.items_list.curselection()
        if not sel: messagebox.showinfo("Info","편집할 블럭을 선택하세요."); return
        idx=sel[0]; it=self.items[idx]
        if isinstance(it,SectionHeader): return
        self.editing_index=idx; b:Block=it; self.rows,self.cols=b.rows,b.cols
        self.cell_colors,self.cell_numbers,self.sockets=dict(b.cell_colors),dict(b.cell_numbers),set(b.sockets)
        self._write_gang_counts(b.gang_counts)
        if b.hold: self.meta_label_type.set("Hold No"); self.meta_no.set(b.hold)
        else: self.meta_label_type.set("Hatch No"); self.meta_no.set(b.hatch)
        self.meta_bay.set(b.bay); self.meta_deck.set(b.deck); self.draw_all(); self.winfo_toplevel().title("Reefer Layout [EDITING]")
    def save_edits(self):
        if self.editing_index is None: return
        b:Block=self.items[self.editing_index]; b.cell_colors,b.cell_numbers,b.sockets=dict(self.cell_colors),dict(self.cell_numbers),set(self.sockets)
        b.gang_counts={g:int(self.gang_vars[g].get() or 0) for g in range(3,10)}
        self.refresh_list(); self.editing_index=None; self.winfo_toplevel().title("Reefer Layout")
        messagebox.showinfo("Saved","블럭 수정이 저장되었습니다.")
    def delete_selected(self):
        sel=self.items_list.curselection()
        if sel and messagebox.askyesno("Confirm","정말로 선택한 아이템을 삭제하시겠습니까?"): del self.items[sel[0]]; self.refresh_list()
    def apply_meta_to_selected(self):
        sel=self.items_list.curselection()
        if not sel: return
        b:Block=self.items[sel[0]]
        if self.meta_label_type.get()=="Hold No": b.hold=self.meta_no.get(); b.hatch=""
        else: b.hatch=self.meta_no.get(); b.hold=""
        b.bay,b.deck=self.meta_bay.get(),self.meta_deck.get(); self.refresh_list()
    def insert_section_at(self,title):
        try: pos=int(self.insert_pos.get())-1
        except(ValueError,TypeError): pos=len(self.items)
        self.items.insert(pos,SectionHeader(title=title)); self.refresh_list()
    def import_from_excel(self):
        path=filedialog.askopenfilename(filetypes=[("Excel","*.xlsx *.xlsm")])
        if not path: return
        try: wb=load_workbook(path,data_only=True); ws=wb.active
        except Exception as e: messagebox.showerror("Error",f"파일 열기 실패:\n{e}"); return
        added,skipped=0,0
        for row in ws.iter_rows(min_row=1,values_only=True):
            if not row or len(row)<2 or row[0] is None or row[1] is None: continue
            try:
                values=[int(p.strip()) for p in str(row[1]).replace("，",",").split(",") if p.strip()]
                if not values: raise ValueError
                rows,cols=len(values),max(values)
                b=Block(rows,cols,cell_colors={})
                for r_idx,cnt in enumerate(values,1):
                    start_c=1+(cols-cnt)//2
                    for k in range(cnt): b.cell_colors[(r_idx,start_c+k)]="#EEEEEE"
                self.items.append(b); added+=1
            except: skipped+=1
        self.refresh_list(); messagebox.showinfo("Import",f"완료: {added}개 블럭 추가, {skipped}행 무시")
    def export_excel(self):
        if not self.items: return
        path=filedialog.asksaveasfilename(defaultextension=".xlsx",filetypes=[("Excel","*.xlsx")])
        if path:
            try: write_excel(self.items,path,self.ship_no.get(),self.looking_txt.get()); messagebox.showinfo("Exported",f"파일 저장 완료:\n{path}")
            except Exception as e: messagebox.showerror("Error",f"저장 실패:\n{e}")

    def auto_set_groups(self):
        sel=self.items_list.curselection()
        targets=[self.items[sel[0]]] if sel and isinstance(self.items[sel[0]],Block) else [it for it in self.items if isinstance(it,Block)]
        if not targets: messagebox.showinfo("Auto Set","대상 블럭이 없습니다."); return
        cap=simpledialog.askinteger("Auto Set","RD panel 당 최대 컨테이너 수",minvalue=4,maxvalue=9999,parent=self)
        if cap is None: return
        even_list,odd_list=self._build_rd_queues()
        rd_remaining={rd:cap for rd in even_list+odd_list}; cur_even,cur_odd=[0],[0]
        for b in targets:
            b.cell_numbers.clear(); b.gang_counts={g:0 for g in range(3,10)}
            active=set(b.cell_colors.keys())
            if not active: continue
            center_col=(b.cols+1)/2.0
            left_active={p for p in active if p[1]<center_col}; right_active={p for p in active if p[1]>center_col}
            center_cells={p for p in active if p[1]==center_col}
            if len(left_active)<=len(right_active): left_active.update(center_cells)
            else: right_active.update(center_cells)
            if b.rows>=6:
                self._place_linear_fill(b,right_active,"RIGHT",rd_remaining,odd_list,cur_odd)
                self._place_linear_fill(b,left_active,"LEFT",rd_remaining,even_list,cur_even)
            else:
                self._place_flexible_fill(b,right_active,"RIGHT",rd_remaining,odd_list,cur_odd)
                self._place_flexible_fill(b,left_active,"LEFT",rd_remaining,even_list,cur_even)
        if self.editing_index is not None: self.edit_selected()
        self.refresh_list(); messagebox.showinfo("Auto Set","완료! (v12: 최종 조합 방식)")

    def _plan_gang_distribution(self, total_size: int) -> List[List[int]]:
        results = []
        gang_options = [9, 8, 7, 6, 5, 4]
        memo = {}
        def find_combinations(remain):
            if remain == 0: return [[]]
            if remain < 4: return []
            if remain in memo: return memo[remain]
            
            combs = []
            for size in gang_options:
                if remain >= size:
                    sub_combs = find_combinations(remain - size)
                    for sub_comb in sub_combs:
                        combs.append([size] + sub_comb)
            memo[remain] = combs
            return combs

        all_combinations = find_combinations(total_size)
        all_combinations.sort(key=lambda x: (len(x), [-v for v in x]))
        return all_combinations

    def _rd_take(self, need, rd_rem, rds, cursor, win=4):
        n=len(rds); i=cursor[0]
        for j in range(i, min(n, i + win)):
            rd = rds[j]
            if rd_rem.get(rd, 0) >= need: rd_rem[rd] -= need; cursor[0] = j + (1 if rd_rem.get(rd, 0) == 0 else 0); return rd
        for j in range(i + win, n):
            rd = rds[j]
            if rd_rem.get(rd, 0) >= need: rd_rem[rd] -= need; return rd
        return None

    def _pick_color(self, cells, b):
        palette = ["#87CEFA","#F6BD60","#F28482","#84A59D","#B8E1DD","#E5989B","#BFD200","#FFBE0B","#9B5DE5"]
        adj = {b.cell_colors[q] for p in cells for q in [(p[0]-1,p[1]),(p[0]+1,p[1]),(p[0],p[1]-1),(p[0],p[1]+1)] if q in b.cell_colors}
        return next((c for c in palette if c not in adj), random.choice(palette))
        
    def _place_linear_fill(self, b, side_active, edge, rd_rem, rds, cursor):
        if not side_active: return
        rows = sorted({r for r,c in side_active})
        for r in rows:
            cols = sorted([c for r_c,c in side_active if r_c==r])
            if not cols: continue
            spans, start = [], cols[0]
            for i in range(1,len(cols)):
                if cols[i]!=cols[i-1]+1: spans.append((start,cols[i-1])); start=cols[i]
            spans.append((start,cols[-1]))
            for start_col, end_col in spans:
                plans = self._plan_gang_distribution(end_col - start_col + 1)
                if not plans: continue
                plan = plans[0]
                ptr = start_col if edge=="LEFT" else end_col
                for size in plan:
                    cells = {(r,c) for c in range(ptr,ptr+size)} if edge=="LEFT" else {(r,c) for c in range(ptr-size+1,ptr+1)}
                    if edge=="LEFT": ptr+=size
                    else: ptr-=size
                    rd = self._rd_take(size, rd_rem, rds, cursor)
                    if rd is not None:
                        color = self._pick_color(cells,b)
                        for cell in cells: b.cell_numbers[cell]=rd; b.cell_colors[cell]=color
                        b.gang_counts[size] = b.gang_counts.get(size,0)+1

    def _place_flexible_fill(self, b: Block, side_active: set, edge: str, rd_rem: Dict, rds: List, cursor: List):
        all_plans = self._plan_gang_distribution(len(side_active))
        if not all_plans: return

        for plan in all_plans:
            placed_cells = set()
            temp_assignments = []
            success = True
            for target_size in plan:
                found_group = None
                is_left = edge == "LEFT"
                search_order = sorted(list(side_active - placed_cells), key=lambda p: (p[0], p[1] if is_left else -p[1]))
                for start_cell in search_order:
                    q = deque([start_cell]); visited = {start_cell}; path = []
                    while q:
                        current = q.popleft(); path.append(current)
                        if len(path) == target_size: break
                        neighbors = [(current[0]+dr, current[1]+dc) for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]]
                        for neighbor in neighbors:
                            if neighbor in (side_active - placed_cells) and neighbor not in visited:
                                temp_group = path + [neighbor]
                                min_r, max_r = min(r for r,c in temp_group), max(r for r,c in temp_group)
                                min_c, max_c = min(c for r,c in temp_group), max(c for r,c in temp_group)
                                if max_r - min_r < 5 and max_c - min_c < 5:
                                    visited.add(neighbor); q.append(neighbor)
                    if len(path) == target_size: found_group = set(path); break
                
                if found_group:
                    temp_assignments.append({'size': target_size, 'cells': found_group})
                    placed_cells.update(found_group)
                else:
                    success = False
                    break
            
            if success:
                for assignment in temp_assignments:
                    size, cells = assignment['size'], assignment['cells']
                    rd = self._rd_take(size, rd_rem, rds, cursor)
                    if rd is not None:
                        color = self._pick_color(cells, b)
                        for cell in cells: b.cell_numbers[cell] = rd; b.cell_colors[cell] = color
                        b.gang_counts[size] = b.gang_counts.get(size, 0) + 1
                return

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Reefer Layout — Auto Set (v12: The True Final Version)")
        try:
            from ctypes import windll; windll.shcore.SetProcessDpiAwareness(1)
        except: pass
        self.geometry("1360x900")
        self.minsize(1200, 800)
        GridCanvas(self)

if __name__ == '__main__':
    app = App()
    app.mainloop()

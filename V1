import tkinter as tk
from tkinter import ttk, messagebox, filedialog, colorchooser, simpledialog
from typing import Set, Tuple, List, Dict, Union, Optional
from dataclasses import dataclass, field
from collections import Counter, OrderedDict
import random
import copy

from openpyxl import Workbook, load_workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side, Font
from openpyxl.utils import get_column_letter
from openpyxl.cell import Cell # Excel 수식 입력을 위해 추가

# --------------------------------
# Types & Models
# --------------------------------
Cell = Tuple[int, int]  # (row, col) 1-based

@dataclass
class Block:
    rows: int
    cols: int
    hatch: str = ""
    hold: str = ""
    bay: str = ""
    deck: str = ""
    cell_colors: Dict[Cell, str] = field(default_factory=dict)
    cell_numbers: Dict[Cell, Union[int, float, str]] = field(default_factory=dict)
    sockets: Set[Cell] = field(default_factory=set)
    gang_counts: Dict[int, int] = field(default_factory=dict)
    # 엑셀 시트 구분을 위해 추가 (LB/HOLD)
    is_hold: bool = field(init=False)

    def __post_init__(self):
        self.is_hold = self.rows >= 6


@dataclass
class SectionHeader:
    title: str

Item = Union[Block, SectionHeader]


# --------------------------------
# Shape Library for Auto-Set
# --------------------------------
SHAPE_LIBRARY: Dict[int, List[List[Cell]]] = {
    9: [
        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)],  # 3x3
        [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3)],
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4)],
        [(0, 1), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (4, 1)],
        [(0, 0), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1)],
        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)],
        [(0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4)],
        [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 1), (1, 2), (1, 3), (1, 4)],
    ],
    8: [
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)],  # 2x4
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],  # 4x2
    ],
    7: [
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2)],
        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (1, 3)],
        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 1)],
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3)],
        [(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)],
        [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0)],
    ],
    6: [
        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)],  # 2x3
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)],  # 3x2
    ],
    5: [
        [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)],  # 1x5
        [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],  # 5x1
    ],
    4: [
        [(0, 0), (0, 1), (1, 0), (1, 1)],  # 2x2
    ],
}
# --------------------------------
# Utils
# --------------------------------
def parse_number_like(s: str) -> Union[int, float, str]:
    try:
        if str(s).strip() == "": return ""
        if "." in str(s):
            f = float(s)
            return int(f) if f.is_integer() else f
        return int(s)
    except (ValueError, TypeError):
        return s

def header_sequence(n: int) -> List[int]:
    evens = [x for x in range(n, 0, -1) if x % 2 == 0]
    odds = list(range(1, n + 1, 2))
    return evens + odds

def set_range_border(ws, min_row, max_row, min_col, max_col, side_top, side_right, side_bottom, side_left):
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            cell = ws.cell(row=r, column=c)
            current_border = cell.border
            new_border = Border(
                top=side_top if r == min_row else current_border.top,
                bottom=side_bottom if r == max_row else current_border.bottom,
                left=side_left if c == min_col else current_border.left,
                right=side_right if c == max_col else current_border.right
            )
            cell.border = new_border

def thick_column_positions(max_grid_cols: int) -> List[int]:
    if max_grid_cols <= 0: return []
    seq = header_sequence(max_grid_cols)
    try:
        boundary_col = seq.index(1) + 1
    except ValueError:
        return []
    pos = {x for x in range(boundary_col, max_grid_cols + 1, 4)}
    pos.update({x for x in range(boundary_col - 4, 0, -4)})
    return sorted(list(pos))

def safe_sheet_title(s: str) -> str:
    invalid_chars = r'[]:*?/\ '
    clean_s = "".join(c if c not in invalid_chars else '-' for c in (s or "Sheet"))
    return clean_s[:31]

# --- [Refactored Helper Functions] ---
# (Moved from GridCanvas class)

def _collect_rd_counts(items: List[Item]) -> OrderedDict:
    """RD 번호별 총 개수를 집계합니다. (GUI용)"""
    c = Counter(int(v) for it in items if isinstance(it,Block) for v in it.cell_numbers.values() if str(v).strip())
    return OrderedDict(sorted(c.items()))

def _rd_list_for_rs(rs_index, rd_per_rs):
    """특정 RS 패널에 할당된 RD 번호 리스트를 반환합니다."""
    if rd_per_rs <= 0 or rs_index <= 0: return []
    if rs_index % 2 == 1:
        # STBD (Odd)
        block_idx = (rs_index - 1) // 2
        start_odd = 1 + 2 * (block_idx * rd_per_rs)
        return [start_odd + 2*i for i in range(rd_per_rs)]
    else:
        # PORT (Even)
        block_idx = (rs_index // 2) - 1
        start_even = 2 + 2 * (block_idx * rd_per_rs)
        return [start_even + 2*i for i in range(rd_per_rs)]

def _build_rd_queues(rs_total, rpr):
    """PORT(Even)와 STBD(Odd)의 RD 대기열을 생성합니다."""
    even_q, odd_q = [], []
    for rs in range(1, rs_total + 1):
        (even_q if rs % 2 == 0 else odd_q).extend(_rd_list_for_rs(rs, rpr))
    return sorted(list(set(even_q))), sorted(list(set(odd_q)))

def _build_rs_summary(rs_indices, rd_counts, rpr):
    """GUI의 Live Summary 텍스트를 생성합니다."""
    lines = []
    for rs in rs_indices:
        rd_list = _rd_list_for_rs(rs, rpr)
        total = sum(rd_counts.get(rd, 0) for rd in rd_list)
        lines.append(f"RS-{rs}: total {total}")
        lines.extend([f"  RD-{rd}: {rd_counts[rd]}" for rd in rd_list if rd_counts.get(rd, 0) > 0])
        if not any(rd_counts.get(rd, 0) > 0 for rd in rd_list):
            lines.append("  -")
        lines.append("")
    return "\n".join(lines).rstrip()

# --- [End Refactored Helper Functions] ---


# --------------------------------
# Excel Writer
# --------------------------------
def write_excel(
    items: List[Item],
    filename: str,
    ship_no: str,
    looking_text: str = "LOOKING TO FWD",
    rs_count_str: str = "0",
    rd_per_rs_str: str = "0",
    row_gap_between_blocks: int = 2,
    info_cols: int = 1, gap_after_info: int = 1,
    deck_cols: int = 1, gap_after_deck: int = 1
):
    if not items:
        raise ValueError("No content to export. Add blocks or section headers.")

    block_cols = [it.cols for it in items if isinstance(it, Block)]
    max_grid_cols = max(block_cols) if block_cols else 6

    grid_start_col = info_cols + gap_after_info + deck_cols + gap_after_deck + 1
    grid_right_col = grid_start_col + max_grid_cols - 1

    # Gang 열 위치 조정: Q'ty 옆으로 이동
    qty_col = grid_right_col + 2 # Q'ty 열 위치 조정
    # gang_gap_col = qty_col + 1 # 제거
    g_start_col = qty_col + 1   # Gang 시작 열 (3)
    g_cols = {g: g_start_col + (g - 3) for g in range(3, 10)}
    g_sum_col = g_start_col + 7 # Gang SUM 열

    wb = Workbook()
    ws = wb.active
    
    sheet_name = safe_sheet_title(ship_no)
    ws.title = sheet_name

    align_center = Alignment(horizontal="center", vertical="center")
    align_right  = Alignment(horizontal="right",  vertical="center")
    thin  = Side(style="thin", color="000000")
    thick = Side(style="thick", color="000000")
    dashed_med = Side(style="mediumDashed", color="000000")
    border_thin   = Border(left=thin, right=thin, top=thin, bottom=thin)
    gray_fill = PatternFill("solid", fgColor="EEEEEE")

    # 열 너비 조정 (Gang 열 이동 고려)
    for c in range(1, g_sum_col + 2): ws.column_dimensions[get_column_letter(c)].width = 4
    for c in range(1, info_cols + 1): ws.column_dimensions[get_column_letter(c)].width = 10
    ws.column_dimensions[get_column_letter(info_cols + 1)].width = 2
    for c in range(info_cols + 2, info_cols + 2 + deck_cols): ws.column_dimensions[get_column_letter(c)].width = 4
    ws.column_dimensions[get_column_letter(info_cols + 2 + deck_cols)].width = 2
    
    ws.column_dimensions[get_column_letter(grid_right_col + 1)].width = 2 # Grid와 Q'ty 사이 간격

    from openpyxl.utils import get_column_letter as _g
    ws.column_dimensions[_g(qty_col)].width = 4 # Q'ty 너비
    for g in range(3, 10): ws.column_dimensions[_g(g_cols[g])].width = 4
    ws.column_dimensions[_g(g_sum_col)].width = 7 # Gang SUM 너비

    title_text = (ship_no.strip() + " Reefer Arrangement") if ship_no.strip() else "Reefer Arrangement"
    try:
        ws.oddHeader.center.text = f"&B&11{title_text}"
        # GUI에서 Header Right 입력 필드를 제거했으므로, 텍스트는 고정적으로 설정
        ws.oddHeader.right.text  = f"&B&11{(looking_text or 'LOOKING TO FWD')}"
    except Exception:
        pass

    left_end = max(1, grid_right_col - 4)
    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=left_end)
    tcell = ws.cell(row=1, column=1, value=title_text)
    tcell.alignment = align_center; tcell.font = Font(size=11, bold=True)
    set_range_border(ws, 1, 1, 1, left_end, thick, thick, thick, thick)

    right_start = left_end + 1
    ws.merge_cells(start_row=1, start_column=right_start, end_row=1, end_column=grid_right_col)
    rcell = ws.cell(row=1, column=right_start, value=(looking_text or "LOOKING TO FWD"))
    rcell.alignment = align_center; rcell.font = Font(size=10)
    set_range_border(ws, 1, 1, right_start, grid_right_col, thick, thick, thick, thick)

    cur_row = 3

    seq = header_sequence(max_grid_cols)
    for i, val in enumerate(seq, start=0):
        cc = grid_start_col + i
        ws.cell(row=cur_row, column=cc, value=int(val)).alignment = align_center
        ws.cell(row=cur_row, column=cc).font = Font(size=9, bold=True)

    # Gang 헤더 위치 조정 (Q'ty 옆)
    ws.merge_cells(start_row=cur_row+1, start_column=g_cols[3], end_row=cur_row+1, end_column=g_sum_col)
    gtitle = ws.cell(row=cur_row+1, column=g_cols[3], value="gang별 수량")
    gtitle.alignment = align_center; gtitle.font = Font(size=9, bold=True)
    for c in range(g_cols[3], g_sum_col + 1):
        ws.cell(row=cur_row+1, column=c).fill = gray_fill

    hrow = cur_row + 2
    # Q'ty 헤더
    ws.cell(row=hrow, column=qty_col, value="Q'ty").alignment = align_center
    # Gang 헤더 (3-9, SUM)
    for g in range(3, 10):
        hc = ws.cell(row=hrow, column=g_cols[g], value=g)
        hc.alignment = align_center; hc.fill = gray_fill
    sm = ws.cell(row=hrow, column=g_sum_col, value="SUM")
    sm.alignment = align_center; sm.fill = gray_fill

    cur_row = hrow + 1
    data_start_row = cur_row 
    
    vertical_thick_cols = set(thick_column_positions(max_grid_cols))
    last_used_row = cur_row
    grand_qty_ranges = []
    
    # LB/HOLD 구분을 위한 gang_summary_rows 딕셔너리
    gang_summary_rows = {'LB': [], 'HOLD': []} 

    count_left_letter  = get_column_letter(grid_start_col)
    count_right_letter = get_column_letter(grid_start_col + max_grid_cols - 1)

    # LB/HOLD 구분을 위한 block 정보 저장 리스트
    block_info_list = [] 

    for idx, it in enumerate(items):
        if isinstance(it, SectionHeader):
            ws.merge_cells(start_row=cur_row, start_column=grid_start_col, end_row=cur_row, end_column=grid_right_col)
            scell = ws.cell(row=cur_row, column=grid_start_col, value=it.title)
            scell.alignment = align_center; scell.font = Font(size=24, bold=True)
            set_range_border(ws, cur_row, cur_row, grid_start_col, grid_right_col, dashed_med, dashed_med, dashed_med, dashed_med)
            cur_row += 4
            last_used_row = max(last_used_row, cur_row - 1) # 갱신
            continue

        b: Block = it
        label_text = f"Hatch No. {b.hatch}" if b.hatch else (f"Hold No. {b.hold}" if b.hold else " ")
        ws.cell(row=cur_row, column=1, value=label_text).alignment = align_center
        ws.cell(row=cur_row, column=1).font = Font(size=8, color="C00000")
        set_range_border(ws, cur_row, cur_row, 1, 1, thin, thin, thin, thin)

        bay_text = f"Bay {b.bay}" if b.bay else " "
        ws.cell(row=cur_row + 1, column=1, value=bay_text).alignment = align_center
        ws.cell(row=cur_row + 1, column=1).font = Font(size=8, color="C00000")
        set_range_border(ws, cur_row + 1, cur_row + 1, 1, 1, thin, thin, thin, thin)

        deck_text = b.deck if b.deck else " "
        ws.cell(row=cur_row, column=info_cols + gap_after_info + 1, value=deck_text).alignment = align_center
        ws.cell(row=cur_row, column=info_cols + gap_after_info + 1).font = Font(size=8, color="C00000")

        left_offset = (max_grid_cols - b.cols) // 2
        block_start_row = cur_row
        block_end_row   = cur_row + b.rows - 1
        grand_qty_ranges.append((block_start_row, block_end_row))

        for r in range(1, b.rows + 1):
            rr = cur_row + r - 1
            ws.row_dimensions[rr].height = 18 
            for c in range(1, b.cols + 1):
                global_grid_col = left_offset + c
                cc = grid_start_col + global_grid_col - 1
                cell = ws.cell(row=rr, column=cc)
                cell.alignment = align_center
                # Block의 cell_colors에 저장된 색상을 사용 (Auto Set/Import에서 지정된 색상)
                if (r,c) in b.cell_colors: cell.fill = PatternFill("solid", fgColor=b.cell_colors[(r,c)].lstrip("#"))
                cell.border = border_thin
                if (r,c) in b.cell_numbers: cell.value = parse_number_like(b.cell_numbers[(r,c)])
                if (r,c) in b.sockets: cell.border = Border(left=Side(style="thick", color="FF0000"), right=Side(style="thick", color="FF0000"), top=Side(style="thick", color="FF0000"), bottom=Side(style="thick", color="FF0000"))
                if global_grid_col in vertical_thick_cols: cell.border = Border(left=thick, right=cell.border.right, top=cell.border.top, bottom=cell.border.bottom)

            # Q'ty 및 Gang 열 수식
            ws.cell(row=rr, column=qty_col, value=f"=COUNT({count_left_letter}{rr}:{count_right_letter}{rr})").alignment = align_center
            ws.cell(row=rr, column=qty_col).font = Font(size=8)
            # Gang 열 회색 배경
            for g in range(3, 10): ws.cell(row=rr, column=g_cols[g]).fill = gray_fill
            ws.cell(row=rr, column=g_sum_col).fill = gray_fill

        sum_row = block_end_row + 1
        
        # LB/HOLD 구분하여 summary row 추가
        block_type = 'HOLD' if b.is_hold else 'LB'
        gang_summary_rows[block_type].append(sum_row)
        
        block_info_list.append({'type': block_type, 'summary_row': sum_row})

        qcol_letter = get_column_letter(qty_col)
        total_cell = ws.cell(row=sum_row, column=qty_col, value=f"=SUM({qcol_letter}{block_start_row}:{qcol_letter}{block_end_row})")
        total_cell.alignment = align_center; total_cell.font = Font(size=8, bold=True)
        total_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)

        terms = []
        for g in range(3, 10):
            cnt = int(b.gang_counts.get(g, 0) or 0)
            cell = ws.cell(row=sum_row, column=g_cols[g], value=cnt)
            cell.alignment = align_center; cell.font = Font(size=8); cell.fill = gray_fill
            terms.append(f"{g}*{get_column_letter(g_cols[g])}{sum_row}")

        gsum_cell = ws.cell(row=sum_row, column=g_sum_col, value="=" + "+".join(terms))
        gsum_cell.alignment = align_center; gsum_cell.font = Font(size=8, bold=True); gsum_cell.fill = gray_fill

        cur_row += max(b.rows, 2) + row_gap_between_blocks
        last_used_row = max(last_used_row, cur_row - 1) # 갱신

    grand_row = last_used_row + 2
    # Grand Total Q'ty
    ws.cell(row=grand_row, column=(qty_col - 1), value="Total").alignment = align_right; ws.cell(row=grand_row, column=(qty_col-1)).font = Font(size=9, bold=True)
    parts = [f"{get_column_letter(qty_col)}{s}:{get_column_letter(qty_col)}{e}" for s, e in grand_qty_ranges]
    grand_qty_cell = ws.cell(row=grand_row, column=qty_col, value=f"=SUM({','.join(parts)})")
    grand_qty_cell.alignment = align_center; grand_qty_cell.font = Font(size=9, bold=True)
    grand_qty_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)

    # Grand Total Gang SUM
    gsum_col_letter = get_column_letter(g_sum_col)
    all_summary_rows = gang_summary_rows['LB'] + gang_summary_rows['HOLD']
    gsum_parts = [f"{gsum_col_letter}{r}" for r in all_summary_rows] if all_summary_rows else ["0"]
    grand_gsum_cell = ws.cell(row=grand_row, column=g_sum_col, value=f"=SUM({','.join(gsum_parts)})")
    grand_gsum_cell.alignment = align_center; grand_gsum_cell.font = Font(size=9, bold=True)
    grand_gsum_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)


    # --- LB / HOLD Gang Totals ---
    lb_hold_start_row = grand_row + 2

    for i, block_type in enumerate(['LB', 'HOLD']):
        current_row = lb_hold_start_row + i
        ws.cell(row=current_row, column=qty_col, value=block_type).alignment = align_right # Q'ty 열에 LB/HOLD 표시
        ws.cell(row=current_row, column=qty_col).font = Font(bold=True)
        
        summary_rows_for_type = gang_summary_rows[block_type]
        
        for g in range(3, 10):
            col_letter = get_column_letter(g_cols[g])
            sum_parts = [f"{col_letter}{r}" for r in summary_rows_for_type] if summary_rows_for_type else ["0"]
            cell = ws.cell(row=current_row, column=g_cols[g], value=f"=SUM({','.join(sum_parts)})")
            cell.alignment = align_center; cell.font = Font(bold=True); cell.border = Border(top=thick, bottom=thick)
            
        # LB/HOLD Gang SUM Total
        gsum_col_letter = get_column_letter(g_sum_col)
        sum_parts_gsum = [f"{gsum_col_letter}{r}" for r in summary_rows_for_type] if summary_rows_for_type else ["0"]
        gsum_total_cell = ws.cell(row=current_row, column=g_sum_col, value=f"=SUM({','.join(sum_parts_gsum)})")
        gsum_total_cell.alignment = align_center; gsum_total_cell.font = Font(bold=True); gsum_total_cell.border = Border(top=thick, bottom=thick)


    for gcol in vertical_thick_cols:
        col_idx = grid_start_col + gcol - 1
        for r in range(data_start_row, last_used_row + 1): 
            cell = ws.cell(row=r, column=col_idx)
            cell.border = Border(left=thick, right=cell.border.right, top=cell.border.top, bottom=cell.border.bottom)

    # --- [START] Summary Sheet V5 Logic ---
    try:
        try: rs_total = int(rs_count_str or 0)
        except ValueError: rs_total = 0
        try: rpr = int(rd_per_rs_str or 0)
        except ValueError: rpr = 0
            
        # --- [BUG FIX: Sheet Name ' 처리] ---
        sheet_name_for_formula = sheet_name.replace("'", "''")
        
        data_range_str = (
            f"'{sheet_name_for_formula}'!"
            f"{get_column_letter(grid_start_col)}{data_start_row}:"
            f"{get_column_letter(grid_right_col)}{last_used_row}"
        )
            
        summary_ws = wb.create_sheet(title="Summary")
        
        _write_summary_sheet_v5(
            summary_ws, 
            rs_total, 
            rpr, 
            data_range_str 
        )
    except Exception as e:
        print(f"Error creating summary sheet: {e}")
    # --- [END] Summary Sheet V5 Logic ---

    wb.save(filename)

# --------------------------------
# Summary Sheet Writer (V5 - Merged RS, No Grand Total, Smaller Font)
# --------------------------------
def _write_summary_sheet_v5(
    ws,
    rs_total: int,
    rpr: int,
    data_range_str: str # 메인 시트의 데이터 범위
):
    """
    (V5) RS/RD 병합, 폰트 축소, Grand Total 제거 + 추가 표 (행 제목 포함) 추가
    """

    from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
    from openpyxl.utils import get_column_letter
    from openpyxl.cell import Cell

    # --- 1. 스타일 정의 (폰트 축소) ---
    ws.font = Font(size=10) # 시트 기본 폰트 10

    bold_font = Font(size=10, bold=True)
    
    # 헤더용 폰트 색상 정의
    stbd_font = Font(size=10, bold=True, color="974706")
    port_font = Font(size=10, bold=True, color="7030A0")
    
    title_font = Font(size=13, bold=True)
    header_fill = PatternFill("solid", fgColor="DDEEFF")
    yellow_fill = PatternFill("solid", fgColor="FFFF00") # 노란색 배경
    total_fill = PatternFill("solid", fgColor="F0F0F0")

    align_left_wrap = Alignment(horizontal="left", vertical="center", wrap_text=True) 
    align_right = Alignment(horizontal="right", vertical="center")
    align_center_wrap = Alignment(horizontal="center", vertical="center", wrap_text=True) 
    align_left = Alignment(horizontal="left", vertical="center") 
    
    thin_side = Side(style="thin", color="000000")
    table_border = Border(left=thin_side, right=thin_side, top=thin_side, bottom=thin_side)
   
    small_font = Font(size=9)

    # --- 2. 헤더 및 열 너비 설정 ---
    
    headers = ["RS", "RD", "REF. CON", "A", "BREAKER", "CABLE", "KVA"]
    
    col_widths = [7.5, 7.5, 8.5, 8, 10.5, 10.5, 9.5] 

    # --- 3. 테이블 작성 헬퍼 함수 ---
    def apply_styles(cell: Cell, font=None, fill=None, align=None, border=None, num_format=None):
        """셀에 스타일을 적용하는 헬퍼"""
        if font: cell.font = font
        if fill: cell.fill = fill
        if align: cell.alignment = align
        if border: cell.border = border
        if num_format: cell.number_format = num_format

    def set_column_widths(c_offset: int, widths: list):
        """지정된 오프셋에 열 너비를 설정하고 자동 크기 조정을 비활성화합니다."""
        for i, width in enumerate(widths, 0):
            col_num = c_offset + i
            if col_num > 0:
                try:
                    col_letter = get_column_letter(col_num)
                    ws.column_dimensions[col_letter].width = round(width + 0.00001)
                    ws.column_dimensions[col_letter].auto_size = False
                except ValueError:
                    print(f"Warning: Invalid column number {col_num} for width setting.")
            else:
                print(f"Warning: Attempted to set width for non-positive column index {col_num}.")
    
    def process_rs_list(rs_list: list, s_row: int, c_offset: int,
                        headers: list, bold_font, header_fill, align_center_wrap, table_border,
                        side: str # <--- [수정 1] side 파라미터 추가
                       ) -> Tuple[int, Dict[int, str]]:
        """
        지정된 RS 리스트에 대한 테이블을 그리고 수식을 채웁니다. (다음 시작 행, {RS번호: REF.CON Total 셀 주소}) 딕셔너리 반환
        """
        # --- [수정 2] LGSP 수식을 위한 Fan Table 범위 정의 ---
        # Fan table 데이터 범위 (헤더 제외, 4행부터 18개 항목 + 5개 빈칸 = 23행 -> 4행~26행)
        fan_data_start_row = 4
        fan_data_end_row = 26 # (3 + 18 + 5)
        
        # 수식에 사용할 절대 참조 범위
        fan_rated_a_range = f"$Y${fan_data_start_row}:$Y${fan_data_end_row}"      # C/Hold fan capacity (Rated, A) (Y열)
        fan_stbd_qty_range = f"$R${fan_data_start_row}:$R${fan_data_end_row}"     # Cargo hold Fan (STBD) Q'ty (R열)
        fan_port_qty_range = f"$U${fan_data_start_row}:$U${fan_data_end_row}"     # Cargo hold Fan (PORT) Q'ty (U열)
        fan_stbd_lgsp_range = f"$S${fan_data_start_row}:$S${fan_data_end_row}"    # Cargo hold Fan (STBD) LGSP No. (S열)
        fan_port_lgsp_range = f"$V${fan_data_start_row}:$V${fan_data_end_row}"    # Cargo hold Fan (PORT) LGSP No. (V열)
        # --- [수정 2 끝] ---
        
        cur_row = s_row
        rs_totals = {} # {RS번호: REF.CON Total 셀 주소}

        if rpr <= 0 or not rs_list:
            # 헤더 그리기
            for i, h in enumerate(headers):
                h_cell = ws.cell(row=cur_row, column=c_offset + i, value=h)
                apply_styles(h_cell, font=bold_font, fill=header_fill, align=align_center_wrap, border=table_border)
            cur_row += 1
            # 빈 데이터 행
            for i, h in enumerate(headers):
                apply_styles(ws.cell(cur_row, c_offset+i), border=table_border)
        
            ws.cell(cur_row, c_offset, "-")
            cur_row += 1
            # LGSP 셀 추가
            lgsp_start_row = cur_row
            lgsp_end_row = lgsp_start_row + 2 # 끝 행 인덱스
            ws.merge_cells(start_row=lgsp_start_row, start_column=c_offset, end_row=lgsp_end_row, end_column=c_offset)
            lgsp_cell = ws.cell(row=lgsp_start_row, column=c_offset, value="LGSP")
            apply_styles(lgsp_cell, align=align_center_wrap, border=table_border)
    
            # --- [수정 3] 병합된 영역 나머지 셀에도 테두리 및 수식 적용 ---
            for r in range(lgsp_start_row, lgsp_end_row + 1):
                # LGSP RD 셀 좌표 (예: B30)
                lgsp_rd_cell_coord = f"{get_column_letter(c_offset + 1)}{r}"
                
                # PORT / STBD에 따라 다른 수식 적용
                if side == "PORT":
                    formula = f"=IFERROR(SUMPRODUCT(--({fan_port_lgsp_range}={lgsp_rd_cell_coord}), {fan_port_qty_range}, {fan_rated_a_range}), 0)"
                else: # STBD
                    formula = f"=IFERROR(SUMPRODUCT(--({fan_stbd_lgsp_range}={lgsp_rd_cell_coord}), {fan_stbd_qty_range}, {fan_rated_a_range}), 0)"

                for i in range(1, len(headers)): # RS 열 제외
                    cell_to_style = ws.cell(r, c_offset + i)
                    
                    if i == 3: # 'A' column (index 3)
                        cell_to_style.value = formula
                        apply_styles(cell_to_style, border=table_border, align=align_right, num_format='0.00')
                    elif i == 1: # 'RD' column (index 1) - 사용자가 입력할 칸
                        apply_styles(cell_to_style, border=table_border, align=align_left_wrap)
                    else:
                        apply_styles(cell_to_style, border=table_border)
            cur_row = lgsp_end_row + 1 # cur_row 업데이트
            # --- [수정 3 끝] ---
        
            # 빈 토탈 행
            apply_styles(ws.cell(cur_row, c_offset, value="Total"), font=bold_font, align=align_left_wrap, fill=total_fill, border=table_border)
            for i in range(1, len(headers)): apply_styles(ws.cell(cur_row, c_offset + i), fill=total_fill, border=table_border)
            cur_row += 2 # 다음 섹션과의 간격 포함
            return cur_row, rs_totals

        for rs in rs_list:
        
            # 각 RS 블록 위에 헤더 행 추가
            for i, h in enumerate(headers):
                h_cell = ws.cell(row=cur_row, column=c_offset + i, value=h)
                apply_styles(h_cell, font=bold_font, fill=header_fill, align=align_center_wrap, border=table_border)
            cur_row += 1
            
            rd_list = _rd_list_for_rs(rs, rpr)
            rs_start_row = cur_row

            if not rd_list:
                ws.merge_cells(start_row=cur_row, start_column=c_offset + 1, end_row=cur_row, end_column=c_offset + 6)
                rs_cell = ws.cell(cur_row, c_offset, f"RS-{rs}")
                apply_styles(rs_cell, font=bold_font, align=align_left_wrap, border=table_border)
                rd_cell = ws.cell(cur_row, c_offset + 1, "  (No RDs)")
                apply_styles(rd_cell, align=align_left_wrap, border=table_border)
                for i in range(2, 7):
                    apply_styles(ws.cell(cur_row, c_offset + i), border=table_border)
                cur_row += 1
                rs_start_row_for_sum = -1
            else:
    
                for rd in rd_list:
                    # c_offset + 2: REF.CON / c_offset + 3: A
                    ref_con_cell_addr = f"{get_column_letter(c_offset + 2)}{cur_row}" 
                    a_cell_addr = f"{get_column_letter(c_offset + 3)}{cur_row}" # D열 또는 L열
   
                    apply_styles(ws.cell(cur_row, c_offset), border=table_border)
                    
                    # RD 항목
                    rd_cell = ws.cell(cur_row, c_offset + 1, f"RD-{rd}") 
                    apply_styles(rd_cell, align=align_left_wrap, border=table_border)
                    
                    # REF.CON 수식
                    ref_cell = ws.cell(cur_row, c_offset + 2, value=f"=COUNTIF({data_range_str},{rd})")
                    apply_styles(ref_cell, align=align_right, border=table_border, num_format='0')
                    
                    # A 수식
                    a_cell = ws.cell(cur_row, c_offset + 3, value=f"={ref_con_cell_addr}*17.4*0.9")
                    apply_styles(a_cell, align=align_right, border=table_border, num_format='0.00')
                    
                    # BREAKER 수식
                    breaker_cell = ws.cell(cur_row, c_offset + 4, value=f'=IF(ROUND({a_cell_addr},2)>=800,"1250/900",IF(ROUND({a_cell_addr},2)>=700,"800/800","800/700"))')
                    apply_styles(breaker_cell, align=align_center_wrap, border=table_border)
                    
                    # --- [CABLE 열 수식 추가] ---
                    cable_cell = ws.cell(cur_row, c_offset + 5)  # F열 또는 N열 (CABLE)
                    cable_cell.value = (
                        f'=IF(ROUND({a_cell_addr},2)>=688.6,"6xT70(169A)",'
                        f'IF(ROUND({a_cell_addr},2)>=626,"5xT70(169A)",""))'
                    )
                    apply_styles(cable_cell, border=table_border, align=align_center_wrap)
                    # --- [끝] ---
                    
                    # KVA 수식
                    kva_cell = ws.cell(cur_row, c_offset + 6, value=f"={ref_con_cell_addr}*10.6") 
                    apply_styles(kva_cell, align=align_right, border=table_border, num_format='0.00')
                    cur_row += 1

                rs_end_row = cur_row - 1
                # RS 셀 병합 및 스타일 적용
                ws.merge_cells(start_row=rs_start_row, start_column=c_offset, end_row=rs_end_row, end_column=c_offset)
                rs_cell = ws.cell(rs_start_row, c_offset, f"RS-{rs}")
                apply_styles(rs_cell, font=bold_font, align=align_center_wrap, border=table_border)
                for r in range(rs_start_row + 1, rs_end_row + 1):
                    apply_styles(ws.cell(r, c_offset), border=table_border)
                rs_start_row_for_sum = rs_start_row

            # --- LGSP 셀 추가 ---
            lgsp_start_row = cur_row
            lgsp_end_row = lgsp_start_row + 2
            ws.merge_cells(start_row=lgsp_start_row, start_column=c_offset, end_row=lgsp_end_row, end_column=c_offset)
            lgsp_cell = ws.cell(row=lgsp_start_row, column=c_offset, value="LGSP")
            
            # --- [수정 4] 병합된 영역 나머지 셀에도 테두리 및 수식 적용 ---
            apply_styles(lgsp_cell, align=align_center_wrap, border=table_border)
            for r in range(lgsp_start_row, lgsp_end_row + 1):
                # LGSP RD 셀 좌표 (예: B30)
                lgsp_rd_cell_coord = f"{get_column_letter(c_offset + 1)}{r}"
                
                # PORT / STBD에 따라 다른 수식 적용
                if side == "PORT":
                    formula = f"=IFERROR(SUMPRODUCT(--({fan_port_lgsp_range}={lgsp_rd_cell_coord}), {fan_port_qty_range}, {fan_rated_a_range}), 0)"
                else: # STBD
                    formula = f"=IFERROR(SUMPRODUCT(--({fan_stbd_lgsp_range}={lgsp_rd_cell_coord}), {fan_stbd_qty_range}, {fan_rated_a_range}), 0)"

                for i in range(1, len(headers)): # RS 열 제외
                    cell_to_style = ws.cell(r, c_offset + i)
                    
                    if i == 3: # 'A' column (index 3)
                        cell_to_style.value = formula
                        apply_styles(cell_to_style, border=table_border, align=align_right, num_format='0.00')
                    elif i == 1: # 'RD' column (index 1) - 사용자가 입력할 칸
                        apply_styles(cell_to_style, border=table_border, align=align_left_wrap)
                    else:
                        apply_styles(cell_to_style, border=table_border)
            cur_row = lgsp_end_row + 1 # cur_row 업데이트
            # --- [수정 4 끝] ---
            # --- LGSP 셀 추가 끝 ---

            total_label_cell = ws.cell(row=cur_row, column=c_offset, value="Total")
            apply_styles(total_label_cell, font=bold_font, align=align_left_wrap, fill=total_fill, border=table_border)
            apply_styles(ws.cell(cur_row, c_offset+1), fill=total_fill, border=table_border)

            if rs_start_row_for_sum == -1:
                ref_sum_formula, a_sum_formula, kva_sum_formula = 0, 0, 0
                ref_total_coord = "0"
            else:
                # 합계 범위 수정: LGSP 행 제외
                rs_end_row_for_sum = lgsp_start_row - 1
                ref_sum_formula = f"=SUM({get_column_letter(c_offset+2)}{rs_start_row_for_sum}:{get_column_letter(c_offset+2)}{rs_end_row_for_sum})"
                a_sum_formula = f"=SUM({get_column_letter(c_offset+3)}{rs_start_row_for_sum}:{get_column_letter(c_offset+3)}{rs_end_row_for_sum})"
                kva_sum_formula = f"=SUM({get_column_letter(c_offset+6)}{rs_start_row_for_sum}:{get_column_letter(c_offset+6)}{rs_end_row_for_sum})"
                ref_total_coord = f"{get_column_letter(c_offset+2)}{cur_row}"

            ref_total_cell = ws.cell(cur_row, c_offset + 2, value=ref_sum_formula)
            apply_styles(ref_total_cell, font=bold_font, align=align_right, fill=total_fill, border=table_border, num_format='0')
            
            rs_totals[rs] = ref_total_coord

            a_total_cell = ws.cell(cur_row, c_offset + 3, value=a_sum_formula)
            apply_styles(a_total_cell, font=bold_font, align=align_right, fill=total_fill, border=table_border, num_format='0.00')
    
            apply_styles(ws.cell(cur_row, c_offset+4), fill=total_fill, border=table_border) # BREAKER Total (blank)
            apply_styles(ws.cell(cur_row, c_offset+5), fill=total_fill, border=table_border) # CABLE Total (blank)
            
            kva_total_cell = ws.cell(row=cur_row, column=c_offset + 6, value=kva_sum_formula)
            apply_styles(kva_total_cell, font=bold_font, align=align_right, fill=total_fill, border=table_border, num_format='0.00')
            cur_row += 1

            cur_row += 1 # 섹션 간 간격
            
        return cur_row, rs_totals 

    # --- 4. 메인 실행 ---

    port_col_offset = 1
    port_title = "PORT"
    even_rs = [i for i in range(1, rs_total + 1) if i % 2 == 0]

    stbd_col_offset = port_col_offset + len(col_widths) + 1
    stbd_title = "STBD"
    odd_rs  = [i for i in range(1, rs_total+1) if i % 2 == 1]

    set_column_widths(port_col_offset, col_widths)
    set_column_widths(stbd_col_offset, col_widths)
    
    gap_col_1_idx = port_col_offset + len(col_widths)
    ws.column_dimensions[get_column_letter(gap_col_1_idx)].width = 5 
    ws.column_dimensions[get_column_letter(gap_col_1_idx)].auto_size = False

    ws.merge_cells(start_row=2, start_column=port_col_offset, end_row=2, end_column=port_col_offset + len(headers) - 1)
    port_title_cell = ws.cell(row=2, column=port_col_offset, value=port_title)
    apply_styles(port_title_cell, font=title_font, align=align_center_wrap)

    ws.merge_cells(start_row=2, start_column=stbd_col_offset, end_row=2, end_column=stbd_col_offset + len(headers) - 1)
    stbd_title_cell = ws.cell(row=2, column=stbd_col_offset, value=stbd_title)
    apply_styles(stbd_title_cell, font=title_font, align=align_center_wrap)

    # --- [수정 5] 2행 높이 25로 설정 ---
    ws.row_dimensions[2].height = 25
    # --- [수정 5 끝] ---
    
    data_start_row = 3 
    port_next_row, port_totals = process_rs_list(
        even_rs, data_start_row, port_col_offset,
        headers, bold_font, header_fill, align_center_wrap, table_border,
        "PORT" # <--- "PORT" 인자 추가
    )
    stbd_next_row, stbd_totals = process_rs_list(
        odd_rs, data_start_row, stbd_col_offset,
        headers, bold_font, header_fill, align_center_wrap, table_border,
        "STBD" # <--- "STBD" 인자 추가
    )
    
    all_rs_totals = {**port_totals, **stbd_totals}
    rs_tables_end_row = max(port_next_row, stbd_next_row) - 1
 
    # --- Fan Table (오른쪽 표) ---
    fan_table_start_col = stbd_col_offset + len(headers) + 1 # P열 -> Q열로 변경 (+1 제거)

    # 간격 열(P열) 너비를 1로 조정
    gap_col_2_idx = fan_table_start_col - 1
    ws.column_dimensions[get_column_letter(gap_col_2_idx)].width = 1
    ws.column_dimensions[get_column_letter(gap_col_2_idx)].auto_size = False

    table1_row_titles = [ # Q열, T열 Description에 들어갈 내용
        "SIDE PASSGAEWAY(FWD)", "No.1A (Exp)", "No.2F (Exp)", "No.3F", "No.4F",
        "SIDE PASSAGEWAY(AFT)", "No.5F1", "No.5F2", "No.5A1", "No.5A2",
        "No.6F1", "No.6F2", "No.6A1", "No.6A2", "No.7F", "No.8F",
        "PIPE DUCT", "No.9F"
    ]
    
    # 새로운 헤더 텍스트 (W열 ~ AE열)
    merged_headers_w_ae = [
        "Total No. of C/Hold fans", 
        "C/Hold fan capacity (Rated, kW)", 
        "C/Hold fan capacity (Rated, A)", 
        "Efficiency", 
        "Load factor", 
        "Div. factor", 
        "Actual power consumption (kW)", 
        "Actual power consumption(STBD, kW)", 
        "Actual power consumption(PORT, kW)"
    ]
    
    # 요청된 새로운 너비 적용 (Q열부터 AE열까지, 총 15개 열)
    new_table1_data_widths = [23, 12, 12, 23, 12, 12, 10.5, 10.5, 10.5, 8, 6, 6, 10.5, 10.5, 10.5]

    fan_title_row = 1
    fan_table_end_col = fan_table_start_col + len(new_table1_data_widths) - 1 # 열 개수 변경 반영
    ws.merge_cells(start_row=fan_title_row, start_column=fan_table_start_col, end_row=fan_title_row, end_column=fan_table_end_col)
    fan_title_cell = ws.cell(row=fan_title_row, column=fan_table_start_col, value="Reefer section에서 배전되는 Fans")
    apply_styles(fan_title_cell, font=bold_font, align=align_left) 

    table1_header_row_2 = 2
    table1_header_row_3 = 3
    
    # P열 너비는 설정 안 함
    set_column_widths(fan_table_start_col, new_table1_data_widths) # Q열부터 너비 적용

    # --- 새로운 헤더 작성 로직 ---
    q_col = fan_table_start_col # Q열 인덱스
    
    # Q2:R2 병합 및 텍스트/스타일 적용 (노란색 배경 추가)
    ws.merge_cells(start_row=table1_header_row_2, start_column=q_col, end_row=table1_header_row_2, end_column=q_col + 1)
    apply_styles(ws.cell(table1_header_row_2, q_col, value="Cargo hold Fan (STBD)"), font=stbd_font, fill=yellow_fill, align=align_center_wrap, border=table_border)
    apply_styles(ws.cell(table1_header_row_2, q_col + 1), fill=yellow_fill, border=table_border) # 병합된 셀 테두리 및 배경
    # Q3, R3 (노란색 배경 추가)
    apply_styles(ws.cell(table1_header_row_3, q_col, value="Description"), font=stbd_font, fill=yellow_fill, align=align_center_wrap, border=table_border)
    apply_styles(ws.cell(table1_header_row_3, q_col + 1, value="Q'ty"), font=stbd_font, fill=yellow_fill, align=align_center_wrap, border=table_border)

    # S2:S3 병합 및 텍스트/스타일 적용 (노란색 배경 추가)
    s_col = q_col + 2
    ws.merge_cells(start_row=table1_header_row_2, start_column=s_col, end_row=table1_header_row_3, end_column=s_col)
    apply_styles(ws.cell(table1_header_row_2, s_col, value="LGSP No."), font=bold_font, fill=yellow_fill, align=align_center_wrap, border=table_border)
    apply_styles(ws.cell(table1_header_row_3, s_col), fill=yellow_fill, border=table_border) # 병합된 셀 테두리 및 배경

    # T2:U2 병합 및 텍스트/스타일 적용 (노란색 배경 추가)
    t_col = s_col + 1
    ws.merge_cells(start_row=table1_header_row_2, start_column=t_col, end_row=table1_header_row_2, end_column=t_col + 1)
    apply_styles(ws.cell(table1_header_row_2, t_col, value="Cargo hold Fan (PORT)"), font=port_font, fill=yellow_fill, align=align_center_wrap, border=table_border)
    apply_styles(ws.cell(table1_header_row_2, t_col + 1), fill=yellow_fill, border=table_border) # 병합된 셀 테두리 및 배경
    # T3, U3 (노란색 배경 추가)
    apply_styles(ws.cell(table1_header_row_3, t_col, value="Description"), font=port_font, fill=yellow_fill, align=align_center_wrap, border=table_border)
    apply_styles(ws.cell(table1_header_row_3, t_col + 1, value="Q'ty"), font=port_font, fill=yellow_fill, align=align_center_wrap, border=table_border)

    # V2:V3 병합 및 텍스트/스타일 적용 (노란색 배경 추가)
    v_col = t_col + 2
    ws.merge_cells(start_row=table1_header_row_2, start_column=v_col, end_row=table1_header_row_3, end_column=v_col)
    apply_styles(ws.cell(table1_header_row_2, v_col, value="LGSP No."), font=bold_font, fill=yellow_fill, align=align_center_wrap, border=table_border)
    apply_styles(ws.cell(table1_header_row_3, v_col), fill=yellow_fill, border=table_border) # 병합된 셀 테두리 및 배경
    
    # W2:AE3 병합 헤더 (기본 배경색 사용)
    w_col = v_col + 1
    for i, header in enumerate(merged_headers_w_ae):
        col_idx = w_col + i
        ws.merge_cells(start_row=table1_header_row_2, start_column=col_idx, end_row=table1_header_row_3, end_column=col_idx)
        cell = ws.cell(row=table1_header_row_2, column=col_idx, value=header)
        # 폰트 색상 조건부 적용
        current_font = bold_font
        if header == "Actual power consumption(STBD, kW)": current_font = stbd_font
        elif header == "Actual power consumption(PORT, kW)": current_font = port_font
        apply_styles(cell, font=current_font, fill=header_fill, align=align_center_wrap, border=table_border)
        apply_styles(ws.cell(table1_header_row_3, col_idx), fill=header_fill, border=table_border) # 병합된 셀 테두리
    # --- 새로운 헤더 작성 로직 끝 ---

    current_row_for_fan_table = table1_header_row_3 + 1 # 데이터 시작 행 변경 (4행부터)
    for title in table1_row_titles:
        row_num = current_row_for_fan_table
        
        # 행 제목을 Q열과 T열에 나눠서 입력
        apply_styles(ws.cell(row_num, q_col, value=title), align=align_left_wrap, border=table_border) # STBD Description (Q)
        apply_styles(ws.cell(row_num, t_col, value=title), align=align_left_wrap, border=table_border) # PORT Description (T)

        # 열 인덱스 재정의 (수식 적용 시 필요) - 열 문자로 변경
        stbd_qty_col_letter = get_column_letter(q_col + 1) # R열
        port_qty_col_letter = get_column_letter(t_col + 1) # U열
        total_fans_col_letter = get_column_letter(w_col) # W열
        cap_kw_col_letter = get_column_letter(w_col + 1) # X열
        cap_a_col_letter = get_column_letter(w_col + 2) # Y열
        eff_col_letter = get_column_letter(w_col + 3) # Z열
        load_col_letter = get_column_letter(w_col + 4) # AA열
        div_col_letter = get_column_letter(w_col + 5) # AB열
        actual_power_col_letter = get_column_letter(w_col + 6) # AC열
        actual_stbd_col_letter = get_column_letter(w_col + 7) # AD열
        actual_port_col_letter = get_column_letter(w_col + 8) # AE열

        # 데이터/수식 적용 (R, U, W ~ AE 열)
        for i in range(len(new_table1_data_widths)):
            col_idx = fan_table_start_col + i
            cell = ws.cell(row=current_row_for_fan_table, column=col_idx)
            
            # 기본 테두리 적용 (Description 열 제외 - 위에서 이미 적용됨)
            if col_idx != q_col and col_idx != t_col:
                apply_styles(cell, border=table_border) 
            
            # 수식 및 값 적용
            if col_idx == q_col + 1: # STBD Q'ty (R열) - 입력값
                 apply_styles(cell, align=align_right, num_format='0') # 사용자가 직접 입력할 칸
            elif col_idx == t_col + 1: # PORT Q'ty (U열) - 입력값
                 apply_styles(cell, align=align_right, num_format='0') # 사용자가 직접 입력할 칸
            elif col_idx == w_col : # Total No. (W열)
                cell.value = f"=SUM(${stbd_qty_col_letter}{row_num},${port_qty_col_letter}{row_num})"
                apply_styles(cell, align=align_right, num_format='0')
            # X열 (Rated, kW), Y열 (Rated, A) - 사용자가 직접 입력할 칸
            elif col_idx == w_col + 1 or col_idx == w_col + 2: 
                 apply_styles(cell, align=align_right, num_format='0.00')
            elif col_idx == w_col + 3: # Efficiency (Z열)
                cell.value = 0.88
                apply_styles(cell, align=align_right, num_format='0.00')
            elif col_idx == w_col + 4: # Load factor (AA열)
                cell.value = 0.8
                apply_styles(cell, align=align_right, num_format='0.0')
            elif col_idx == w_col + 5: # Div. factor (AB열)
                cell.value = 1
                apply_styles(cell, align=align_right, num_format='0')
            elif col_idx == w_col + 6: # Actual power consumption (kW) (AC열)
                 cell.value = f"=IFERROR((${cap_kw_col_letter}{row_num}/${eff_col_letter}{row_num})*${load_col_letter}{row_num}*${div_col_letter}{row_num}, 0)"
                 apply_styles(cell, align=align_right, num_format='0.00')
            elif col_idx == w_col + 7: # Actual power consumption(STBD, kW) (AD열)
                 cell.value = f"=IFERROR((${actual_power_col_letter}{row_num}/${total_fans_col_letter}{row_num})*${stbd_qty_col_letter}{row_num}, 0)" # 수정된 수식
                 apply_styles(cell, align=align_right, num_format='0.00')
            elif col_idx == w_col + 8: # Actual power consumption(PORT, kW) (AE열)
                 cell.value = f"=IFERROR((${actual_power_col_letter}{row_num}/${total_fans_col_letter}{row_num})*${port_qty_col_letter}{row_num}, 0)" # 수정된 수식
                 apply_styles(cell, align=align_right, num_format='0.00')
            # S열, V열 (LGSP No.)은 비워둠 (사용자가 입력)
            elif col_idx == s_col or col_idx == v_col:
                 apply_styles(cell, align=align_center_wrap)


        current_row_for_fan_table += 1

    # 빈 행 5개 추가
    for _ in range(5):
        # Q, T열 Description에도 테두리 적용
        apply_styles(ws.cell(current_row_for_fan_table, q_col), align=align_left_wrap, border=table_border)
        apply_styles(ws.cell(current_row_for_fan_table, t_col), align=align_left_wrap, border=table_border)
        # 나머지 열 테두리 적용
        for i in range(len(new_table1_data_widths)):
             col_idx = fan_table_start_col + i
             if col_idx != q_col and col_idx != t_col:
                 apply_styles(ws.cell(current_row_for_fan_table, col_idx), border=table_border)
        current_row_for_fan_table += 1

    fan_table_end_row = current_row_for_fan_table - 1

    # Reefer CNTR 계산 테이블 위치 조정 (한 행 더 내림)
    REEFER_TABLE_ROW_GAP = 2 # 1 -> 2
    reefer_title_row = fan_table_end_row + REEFER_TABLE_ROW_GAP

    # Reefer CNTR 테이블 헤더 및 너비 (이전 요청 반영)
    table2_horizontal_headers = [
        "Reefer Section board", "Ref. container (FEU)", "Ref. container (kVA)",
        "Cargo fan(kVA)", "Total capacity (kVA)", "TR capacity (kVA)", 
        "TR capacity (SPEC)"
    ]
    # 요청된 table2_data_widths 값 반영
    table2_data_widths = [12, 12, 23, 12, 10.5, 10.5] 

    table2_vertical_headers = []
    if rs_total > 0:
        for i in range(1, rs_total + 1):
            suffix = "(S)" if i % 2 == 1 else "(P)"
            table2_vertical_headers.append(f"RS-{i} {suffix}")
    
    table2_vertical_header_width = 23

    table2_header_row = reefer_title_row + 1 
    
    reefer_table_end_col = fan_table_start_col + len(table2_horizontal_headers) - 1 # fan_table_start_col 기준으로 변경
    ws.merge_cells(start_row=reefer_title_row, start_column=fan_table_start_col, end_row=reefer_title_row, end_column=reefer_table_end_col)
    reefer_title_cell = ws.cell(row=reefer_title_row, column=fan_table_start_col, value="Reefer CNTR 계산")
    apply_styles(reefer_title_cell, font=bold_font, align=align_left)

    ws.column_dimensions[get_column_letter(fan_table_start_col)].width = round(table2_vertical_header_width)
    ws.column_dimensions[get_column_letter(fan_table_start_col)].auto_size = False
    set_column_widths(fan_table_start_col + 1, table2_data_widths) 

    # --- Reefer CNTR 헤더 병합 및 스타일 적용 ---
    for i, header in enumerate(table2_horizontal_headers):
        col_idx = fan_table_start_col + i
        # 헤더 셀과 아래 셀 병합
        ws.merge_cells(start_row=table2_header_row, start_column=col_idx, end_row=table2_header_row + 1, end_column=col_idx)
        cell = ws.cell(row=table2_header_row, column=col_idx, value=header)
        # TR capacity(SPEC) 헤더만 노란색 배경 적용
        fill_color = yellow_fill if header == "TR capacity(SPEC)" else header_fill
        apply_styles(cell, font=bold_font, fill=fill_color, align=align_center_wrap, border=table_border)
        # 병합된 아래 셀에도 스타일 적용 (테두리, 배경)
        apply_styles(ws.cell(table2_header_row + 1, col_idx), fill=fill_color, border=table_border)
        
    current_row_for_reefer_table = table2_header_row + 2 # 데이터 시작 행 변경 (병합으로 인해 +2)
    
    table2_colors = ["EBF1DE", "D8E4BC", "E4DFEC", "CCC0DA", "DAEEF3", "B7DEE8"]
    num_colors = len(table2_colors)
    
    for idx, title in enumerate(table2_vertical_headers):
        rs_index = idx + 1 
        
        color_hex = table2_colors[idx % num_colors]
        row_fill = PatternFill("solid", fgColor=color_hex)

        cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col, value=title)
        apply_styles(cell, align=align_left_wrap, border=table_border, font=bold_font, fill=row_fill)
        
        ref_con_total_addr = all_rs_totals.get(rs_index, "0")
        ref_feu_cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col + 1, value=f"={ref_con_total_addr}")
        apply_styles(ref_feu_cell, border=table_border, fill=row_fill, align=align_right, num_format='0')

        ref_kva_cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col + 2)
        apply_styles(ref_kva_cell, border=table_border, fill=row_fill, align=align_right, num_format='0.00')

        cargo_fan_cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col + 3)
        apply_styles(cargo_fan_cell, border=table_border, fill=row_fill)

        # Total capacity cell index: fan_table_start_col + 4
        total_cap_cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col + 4, 
                                 value=f"=SUM({ref_kva_cell.coordinate},{cargo_fan_cell.coordinate})") # sox_cell 제거
        apply_styles(total_cap_cell, border=table_border, fill=row_fill, align=align_right, num_format='0.00')

        # TR capacity cell index: fan_table_start_col + 5
        tr_cap_cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col + 5)
        apply_styles(tr_cap_cell, border=table_border, fill=row_fill, align=align_right, num_format='0.00')
    
        # TR spec cell index: fan_table_start_col + 6 (데이터 셀은 row_fill 적용)
        tr_spec_cell = ws.cell(row=current_row_for_reefer_table, column=fan_table_start_col + 6)
        apply_styles(tr_spec_cell, border=table_border, fill=row_fill) # 헤더와 달리 데이터 셀은 기존 row_fill 사용

        current_row_for_reefer_table += 1
    reefer_table_end_row = current_row_for_reefer_table - 1

    tr_table_start_row = reefer_table_end_row + 2

    cell_r1_c1 = ws.cell(row=tr_table_start_row, column=fan_table_start_col, value="Reefer cntr for TR")
    apply_styles(cell_r1_c1, align=align_left_wrap, border=table_border, font=bold_font)
    cell_r1_c2 = ws.cell(row=tr_table_start_row, column=fan_table_start_col + 1, value=10.6)
    apply_styles(cell_r1_c2, align=align_right, border=table_border, num_format='0.0" kVA"')
    
    tr_k_per_cntr_addr_abs = f"${get_column_letter(cell_r1_c2.column)}${cell_r1_c2.row}"
    
    tr_table_current_row = tr_table_start_row + 1
    cell_r2_c1 = ws.cell(row=tr_table_current_row, column=fan_table_start_col, value="TR efficiency")
    apply_styles(cell_r2_c1, align=align_left_wrap, border=table_border, font=bold_font)
    
    cell_r2_c2 = ws.cell(row=tr_table_current_row, column=fan_table_start_col + 1, value=0.95)
    apply_styles(cell_r2_c2, align=align_right, border=table_border, num_format='0.00')

    tr_eff_addr_abs = f"${get_column_letter(cell_r2_c2.column)}${cell_r2_c2.row}"

    # "실제 TR도면..." 셀 병합 (오른쪽 셀과)
    note_col_start = fan_table_start_col + 2
    ws.merge_cells(start_row=tr_table_current_row, start_column=note_col_start, end_row=tr_table_current_row, end_column=note_col_start + 1)
    cell_r2_c3 = ws.cell(row=tr_table_current_row, column=note_col_start, value="실제 TR도면 접수 후 다시 기입")
    apply_styles(cell_r2_c3, align=align_left_wrap, border=None, font=small_font)
    apply_styles(ws.cell(tr_table_current_row, note_col_start + 1), border=None) # 병합된 셀 테두리 제거


    for r_idx in range(table2_header_row + 2, reefer_table_end_row + 1): # 데이터 시작 행 변경 반영 (+2)
        ref_feu_cell_coord = ws.cell(row=r_idx, column=fan_table_start_col + 1).coordinate
        
        ref_kva_cell = ws.cell(row=r_idx, column=fan_table_start_col + 2)
        ref_kva_cell.value = f"={ref_feu_cell_coord}*{tr_k_per_cntr_addr_abs}"

        # Total capacity cell index: fan_table_start_col + 4
        total_cap_cell_coord = ws.cell(row=r_idx, column=fan_table_start_col + 4).coordinate 
        # TR capacity cell index: fan_table_start_col + 5
        tr_cap_cell = ws.cell(row=r_idx, column=fan_table_start_col + 5)
        tr_cap_cell.value = f"=IFERROR({total_cap_cell_coord}/{tr_eff_addr_abs},0)"


# --------------------------------
# GUI
# --------------------------------
class GridCanvas(ttk.Frame):
    def __init__(self, master):
        super().__init__(master, padding=10)
        self.pack(fill="both", expand=True)

        self.rows, self.cols, self.cell_px = 4, 20, 22
        self.cell_colors, self.cell_numbers, self.sockets = {}, {}, set()
        
        # Mode management (Changed to BooleanVars)
        # 초기 상태: 아무것도 선택되지 않음
        self.mode_color = tk.BooleanVar(value=False) 
        self.mode_number = tk.BooleanVar(value=False)
        self.mode_eraser = tk.BooleanVar(value=False)
        self.mode_socket = tk.BooleanVar(value=False)

        self.current_label = tk.StringVar(value="1")
        # 요청에 따라 4개의 고정 색상 팔레트 정의
        self.FIXED_COLORS = ["#FFFF99", "#99CCFF", "#CCFFCC", "#F2DCDB"] 
        self.current_color = tk.StringVar(value=self.FIXED_COLORS[0])
        
        self.ship_no = tk.StringVar(value="")
        self.looking_txt = tk.StringVar(value="LOOKING TO FWD") 
        self.rs_count = tk.StringVar(value="0")
        self.rd_per_rs = tk.StringVar(value="0")
        
        self.gang_vars = {g: tk.StringVar(value="0") for g in range(3, 10)}
        self.items: List[Item] = []
        self.editing_index: Optional[int] = None
        self.drag_start, self.drag_rect_id = None, None
        
        self.drag_start_right, self.drag_rect_id_right = None, None
        self.insert_pos = tk.StringVar(value="1")
        self.undo_stack = []

        self.rs_count.trace_add("write", self._recompute_all)
        self.rd_per_rs.trace_add("write", self._recompute_all)

        
        self._create_widgets()
        self.draw_all()
        self._recompute_all()
        self._update_insert_spin_range()
        self._update_ui_visibility() # Initial visibility update

    # 색상 설정 헬퍼 함수 추가
    def set_current_color(self, hx: str):
        self.current_color.set(hx)
        self.color_preview.config(bg=hx)

    # Pick Color 함수 이름 변경 및 수정
    def pick_color_dialog(self):
        _, hx = colorchooser.askcolor(color=self.current_color.get(), title="Pick Color")
        if hx:
            self.set_current_color(hx)

    def _toggle_mode(self, mode_var: tk.BooleanVar, exclusive: bool, button: ttk.Button):
        """모드 버튼 클릭에 따라 상태를 전환하고 UI 가시성을 업데이트합니다."""
        
        if exclusive:
            # ERASER 또는 SOCKET (배타적 모드)
            was_on = mode_var.get()
            
            # 모든 모드를 끄기
            self.mode_color.set(False)
            self.mode_number.set(False)
            self.mode_eraser.set(False)
            self.mode_socket.set(False)
            
            # 클릭된 모드만 상태 반전 (토글)
            mode_var.set(not was_on)
        else:
            # COLOR 또는 NUMBER (동시 선택 가능 모드)
            
            # 배타적 모드가 켜져 있다면, 해당 모드들을 끄고 현재 모드 상태 토글
            if self.mode_eraser.get() or self.mode_socket.get():
                self.mode_eraser.set(False)
                self.mode_socket.set(False)
                mode_var.set(True)
            else:
                mode_var.set(not mode_var.get())

        # Update all button appearances after any mode change
        self._update_all_button_appearances()
        self._update_ui_visibility()

    def _update_button_appearance(self, button: ttk.Button, is_selected: bool):
        """버튼의 외관을 선택 상태에 따라 변경합니다. (ttk 오류 회피: state 사용)"""
        if is_selected:
            # 'pressed' 상태를 사용하여 눌린 것처럼 보이게 함 (다른 상태와 함께 사용 가능)
            button.state(['pressed']) 
        else:
            # 'pressed' 상태 해제
            button.state(['!pressed'])


    def _update_all_button_appearances(self):
        """모든 모드 버튼의 외관을 현재 상태에 맞게 업데이트합니다."""
        self._update_button_appearance(self.btn_color, self.mode_color.get())
        self._update_button_appearance(self.btn_number, self.mode_number.get())
        self._update_button_appearance(self.btn_eraser, self.mode_eraser.get())
        self._update_button_appearance(self.btn_socket, self.mode_socket.get())


    def _update_ui_visibility(self):
        """현재 모드 상태에 따라 Number/Color UI의 가시성을 제어합니다."""
        
        # Number Frame Visibility
        if self.mode_number.get():
            self.number_frame.grid(row=1, column=2, columnspan=2, sticky="ew") # sticky 변경
        else:
            self.number_frame.grid_forget()

        # Color Frame Visibility
        if self.mode_color.get():
            self.color_frame.grid(row=1, column=4, columnspan=5, sticky="ew") # sticky 변경
        else:
            self.color_frame.grid_forget()
            
        # Mode Label Text Update Removed

    def _create_widgets(self):
        outer = ttk.Frame(self); outer.pack(fill="both", expand=True)
        right = ttk.Frame(outer); right.pack(side="right", fill="y", padx=(10, 0))
        left = ttk.Frame(outer); left.pack(side="left", fill="both", expand=True)

        cfg = ttk.LabelFrame(right, text="RS / RD Panels", padding=10)
        cfg.pack(fill="x", pady=(0, 10))
        ttk.Label(cfg, text="RS Panels").grid(row=0, column=0, sticky="e", padx=5, pady=2)
        ttk.Spinbox(cfg, from_=0, to=999, textvariable=self.rs_count, width=8).grid(row=0, column=1, sticky="w", pady=2)
        ttk.Label(cfg, text="RD per RS").grid(row=0, column=2, sticky="e", padx=5, pady=2)
        ttk.Spinbox(cfg, from_=0, to=999, textvariable=self.rd_per_rs, width=8).grid(row=0, column=3, sticky="w", pady=2)

        # --- [GUI MOD] ---
        summary_frame = ttk.LabelFrame(right, text="Live Summary", padding=10)
        summary_frame.pack(fill="both", expand=True, pady=(0, 10)) 

        self.grand_total_label = ttk.Label(summary_frame, text="Grand Total: 0", font=("Segoe UI", 9, "bold"))
        self.grand_total_label.pack(anchor="w", pady=(0, 5))

        alloc = ttk.Frame(summary_frame); alloc.pack(fill="both", expand=True)
        left_col = ttk.Frame(alloc); left_col.pack(side="left", fill="both", expand=True, padx=(0,5))
        ttk.Label(left_col, text="PORT RS").pack(anchor="w")
        self.txt_even = tk.Text(left_col, width=15, height=34, font=("Consolas", 10)); self.txt_even.pack(fill="both", expand=True); self.txt_even.configure(state="disabled")
        
        right_col = ttk.Frame(alloc); right_col.pack(side="left", fill="both", expand=True, padx=(5,0))
        ttk.Label(right_col, text="STBD RS").pack(anchor="w")
        self.txt_odd = tk.Text(right_col, width=15, height=34, font=("Consolas", 10)); self.txt_odd.pack(fill="both", expand=True); self.txt_odd.configure(state="disabled")
        # --- [END GUI MOD] ---

        top = ttk.Frame(left); top.pack(fill="x", pady=(0, 10))
        # 컬럼 가중치 설정 (Pick 버튼 잘림 방지)
        top.columnconfigure(6, weight=1) 
        
        ttk.Label(top, text="Ship No.").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        ttk.Entry(top, textvariable=self.ship_no, width=14).grid(row=0, column=1, sticky="w", padx=(0,12), pady=2)
        
        
        # --- Mode Buttons ---
        mode_btn_frame = ttk.Frame(top)
        mode_btn_frame.grid(row=0, column=2, columnspan=8, sticky="w", padx=4, pady=2)
        
        # Mode Label Removed

        # Buttons creation (store references)
        self.btn_color = ttk.Button(mode_btn_frame, text="COLOR", 
                                    command=lambda: self._toggle_mode(self.mode_color, False, self.btn_color))
        self.btn_color.pack(side="left", padx=2)
        
        self.btn_number = ttk.Button(mode_btn_frame, text="NUMBER", 
                                     command=lambda: self._toggle_mode(self.mode_number, False, self.btn_number))
        self.btn_number.pack(side="left", padx=2)
        
        self.btn_eraser = ttk.Button(mode_btn_frame, text="ERASER", 
                                     command=lambda: self._toggle_mode(self.mode_eraser, True, self.btn_eraser))
        self.btn_eraser.pack(side="left", padx=(10, 2))
        
        self.btn_socket = ttk.Button(mode_btn_frame, text="SOCKET", 
                                     command=lambda: self._toggle_mode(self.mode_socket, True, self.btn_socket))
        self.btn_socket.pack(side="left", padx=2)

        # Initial appearance setup using state (모두 선택 안 함)
        self._update_all_button_appearances()
        
        # --- Color / Number Inputs (Visibility controlled) ---
        
        # Number Frame (Grid location is placeholder, controlled by _update_ui_visibility)
        self.number_frame = ttk.Frame(top)
        ttk.Label(self.number_frame, text="Number").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        ttk.Entry(self.number_frame, textvariable=self.current_label, width=10).grid(row=0, column=1, sticky="w", padx=(0,12), pady=2)
        
        # Color Frame (Grid location is placeholder, controlled by _update_ui_visibility)
        self.color_frame = ttk.Frame(top)
        ttk.Label(self.color_frame, text="Color").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        
        color_col_start = 1
        for i, color in enumerate(self.FIXED_COLORS):
            btn = tk.Button(self.color_frame, text=" ", bg=color, width=2, relief="raised", 
                            command=lambda c=color: self.set_current_color(c))
            btn.grid(row=0, column=color_col_start + i, sticky="w", padx=(1, 1), pady=2)
            
        self.color_preview = tk.Label(self.color_frame, text="   ", bg=self.current_color.get(), relief="groove", width=4)
        self.color_preview.grid(row=0, column=color_col_start + len(self.FIXED_COLORS), sticky="w", padx=(0,4), pady=2)
        ttk.Button(self.color_frame, text="Pick…", command=self.pick_color_dialog).grid(row=0, column=color_col_start + len(self.FIXED_COLORS) + 1, sticky="w", padx=(2,12), pady=2)

        # Main Button Row
        btn_row = ttk.Frame(left); btn_row.pack(fill="x", pady=5)
        ttk.Button(btn_row, text="Import…", command=self.import_from_excel).grid(row=0, column=0, padx=2, pady=2)
        ttk.Button(btn_row, text="Save", command=self.save_edits).grid(row=0, column=1, padx=2, pady=2)
        ttk.Button(btn_row, text="Auto Set", command=self.auto_set_groups).grid(row=0, column=2, padx=(12,2), pady=2)
        ttk.Button(btn_row, text="Undo", command=self.undo).grid(row=0, column=3, padx=2, pady=2)
        ttk.Button(btn_row, text="Clear All", command=self.clear_all).grid(row=0, column=4, padx=2, pady=2)
        ttk.Button(btn_row, text="Export…", command=self.export_excel).grid(row=0, column=5, padx=(12,2), pady=2)

        self.canvas = tk.Canvas(left, bg="white", highlightthickness=1, highlightbackground="#cccccc")
        self.canvas.pack(fill="both", expand=True, pady=5)
        self.canvas.bind("<Button-1>", self.on_press); self.canvas.bind("<B1-Motion>", self.on_drag); self.canvas.bind("<ButtonRelease-1>", self.on_release)
        self.canvas.bind("<Button-3>", self.on_press_right); self.canvas.bind("<B3-Motion>", self.on_drag_right); self.canvas.bind("<ButtonRelease-3>", self.on_release_right)
        self.canvas.bind("<Control-Button-1>", self.on_press_right); self.canvas.bind("<Control-B1-Motion>", self.on_drag_right); self.canvas.bind("<Control-ButtonRelease-1>", self.on_release_right)

        gang_row = ttk.Frame(left); gang_row.pack(fill="x", pady=5)
        ttk.Label(gang_row, text="Gang per Block").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        col = 1
        for g in range(3, 10):
            ttk.Label(gang_row, text=f"{g}").grid(row=0, column=col, sticky="e", padx=4, pady=2)
            ttk.Entry(gang_row, textvariable=self.gang_vars[g], width=5).grid(row=0, column=col+1, sticky="w", padx=(0,8), pady=2)
            col += 2

        bottom = ttk.Frame(left); bottom.pack(fill="x", pady=5)
        ttk.Label(bottom, text="Items (Blocks / Sections)").pack(anchor="w")
        self.items_list = tk.Listbox(bottom, height=8); self.items_list.pack(fill="x", expand=True)
        self.items_list.bind("<Double-Button-1>", lambda e: self.edit_selected())
        self.items_list.bind("<Button-3>", self._show_context_menu)
        
        self.context_menu = tk.Menu(self.items_list, tearoff=0)
        self.context_menu.add_command(label="Delete Block", command=lambda: self.context_menu_action("DELETE"))
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Insert ACCOMMODATION", command=lambda: self.context_menu_action("INSERT_ACCOMMODATION"))
        self.context_menu.add_command(label="Insert E/R CASING", command=lambda: self.context_menu_action("INSERT_E/R CASING"))
        
        meta = ttk.LabelFrame(left, text="Block Meta", padding=10)
        meta.pack(fill="x", pady=5)
        self.meta_label_type = tk.StringVar(value="Hatch No")
        ttk.Label(meta, text="Label Type").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        ttk.Combobox(meta, textvariable=self.meta_label_type, values=["Hatch No", "Hold No"], width=10, state="readonly").grid(row=0, column=1, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="No.").grid(row=0, column=2, sticky="e", padx=8, pady=2)
        self.meta_no = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_no, width=10).grid(row=0, column=3, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="Bay").grid(row=1, column=0, sticky="e", padx=4, pady=2)
        self.meta_bay = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_bay, width=10).grid(row=1, column=1, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="Deck").grid(row=1, column=2, sticky="e", padx=8, pady=2)
        self.meta_deck = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_deck, width=12).grid(row=1, column=3, sticky="w", padx=4, pady=2)
        ttk.Button(meta, text="Apply to Selected", command=self.apply_meta_to_selected).grid(row=0, column=4, rowspan=2, sticky="nsw", padx=(12,4), pady=2)

    def _save_state_for_undo(self):
        state = {
            'items': copy.deepcopy(self.items),
            'editing_index': self.editing_index,
            'canvas_data': (copy.deepcopy(self.cell_colors), copy.deepcopy(self.cell_numbers), copy.deepcopy(self.sockets))
        }
        self.undo_stack.append(state)
        if len(self.undo_stack) > 10:
            self.undo_stack.pop(0)

    def undo(self):
        if not self.undo_stack:
            messagebox.showinfo("Undo", "더 이상 되돌릴 작업이 없습니다.")
            return

        state = self.undo_stack.pop()
        self.items = state['items']
        self.editing_index = state['editing_index']
        self.cell_colors, self.cell_numbers, self.sockets = state['canvas_data']
        
        # 모드 상태 초기화 (필수) - 초기값은 아무것도 선택 안 함으로 변경
        self.mode_color.set(False); self.mode_number.set(False); self.mode_eraser.set(False); self.mode_socket.set(False)
        self._update_all_button_appearances() # Update button appearances
        self._update_ui_visibility()

        if self.editing_index is not None:
            self.edit_selected()
        else:
            self.draw_all()

        self.refresh_list()
        self._recompute_all()

    def clear_all(self):
        if messagebox.askyesno("Clear All", "모든 블럭과 작업 내용을 정말로 초기화하시겠습니까?"):
            self._save_state_for_undo()
            self.items.clear()
            self.editing_index = None
            self.clear_canvas()
            self.refresh_list()
            self.winfo_toplevel().title("Reefer Layout")

    def _recompute_all(self, *args):
        self._update_allocation_display()

    def _update_allocation_display(self):
        try:
            rs_total = int(self.rs_count.get() or 0)
            rpr = int(self.rd_per_rs.get() or 0)
        except(ValueError, TypeError):
            rs_total = 0
            rpr = 0

        even_rs = [i for i in range(1, rs_total+1) if i % 2 == 0]
        odd_rs  = [i for i in range(1, rs_total+1) if i % 2 == 1]

        rd_counts = _collect_rd_counts(self.items)
   
        grand_total = sum(rd_counts.values())
        self.grand_total_label.config(text=f"Grand Total: {grand_total}")

        for txt_widget, indices in [(self.txt_even, even_rs), (self.txt_odd, odd_rs)]:
            content = _build_rs_summary(indices, rd_counts, rpr)
            txt_widget.config(state="normal")
            txt_widget.delete("1.0", tk.END)
            txt_widget.insert(tk.END, content)
            txt_widget.config(state="disabled")

    def clear_canvas(self):
        self.cell_colors.clear(); self.cell_numbers.clear(); self.sockets.clear()
        self.draw_all()

    def cell_to_xy(self, r, c):
        x1, y1 = (c - 1) * self.cell_px + 1, (r - 1) * self.cell_px + 1
        return x1, y1, x1 + self.cell_px, y1 + self.cell_px

    def xy_to_cell(self, x, y):
        c, r = int((x - 1) // self.cell_px) + 1, int((y - 1) // self.cell_px) + 1
        return (r, c) if 1 <= r <= self.rows and 1 <= c <= self.cols else None

    def draw_all(self):
        self.canvas.delete("all")
        self.canvas.config(width=self.cols * self.cell_px + 2, height=self.rows * self.cell_px + 2)
        for r in range(1, self.rows + 1):
            for c in range(1, self.cols + 1):
                x1, y1, x2, y2 = self.cell_to_xy(r, c)
                self.canvas.create_rectangle(x1, y1, x2, y2, fill=self.cell_colors.get((r, c), "#FFFFFF"), outline="#CCCCCC")
        for r, c in self.sockets:
            x1, y1, x2, y2 = self.cell_to_xy(r, c)
            self.canvas.create_rectangle(x1 + 1, y1 + 1, x2 - 1, y2 - 1, outline="#FF0000", width=2)
        for (r, c), val in self.cell_numbers.items():
            x, y = (c - 0.5) * self.cell_px, (r - 0.5) * self.cell_px
            self.canvas.create_text(x, y, text=str(val), font=("Arial", 8))

    def on_press(self, e):
        self._save_state_for_undo()
        self.drag_start = self.xy_to_cell(e.x, e.y)
        self.update_drag_rect(e, left_click=True)

    def on_drag(self, e):
        self.update_drag_rect(e, left_click=True)

    def on_release(self, e):
        if self.drag_rect_id:
            self.canvas.delete(self.drag_rect_id)
            self.drag_rect_id = None
        if not self.drag_start: return
        end_cell = self.xy_to_cell(e.x, e.y) or self.drag_start
        r1, c1 = self.drag_start
        r2, c2 = end_cell
        
        # Update logic based on BooleanVars
        is_color = self.mode_color.get()
        is_number = self.mode_number.get()
        is_eraser = self.mode_eraser.get()
        is_socket = self.mode_socket.get()
        
        for r in range(min(r1, r2), max(r1, r2) + 1):
            for c in range(min(c1, c2), max(c1, c2) + 1):
                pos = (r, c)
                
                if is_eraser: 
                    self.cell_colors.pop(pos, None); self.cell_numbers.pop(pos, None); self.sockets.discard(pos)
                elif is_socket:
                    self.sockets.add(pos)
                
                # Color and Number can be set simultaneously
                # Apply only if not in eraser or socket mode
                elif is_color or is_number:
                    if is_color: 
                        self.cell_colors[pos] = self.current_color.get()
                    if is_number: 
                        self.cell_numbers[pos] = parse_number_like(self.current_label.get())
        
        self.drag_start = None
        self.draw_all()
        self._recompute_all()

    def on_press_right(self, e):
        self._save_state_for_undo()
        self.drag_start_right = self.xy_to_cell(e.x, e.y)
        self.update_drag_rect(e, left_click=False)

    def on_drag_right(self, e):
        self.update_drag_rect(e, left_click=False)

    def on_release_right(self, e):
        if self.drag_rect_id_right:
            self.canvas.delete(self.drag_rect_id_right)
            self.drag_rect_id_right = None
        if not self.drag_start_right: return
        end_cell = self.xy_to_cell(e.x, e.y) or self.drag_start_right
        r1, c1 = self.drag_start_right
        r2, c2 = end_cell
        
        # Right click behavior is defined as clearing/erasing (pop/discard) based on selected mode.
        is_color = self.mode_color.get()
        is_number = self.mode_number.get()
        is_socket = self.mode_socket.get()
        # Eraser doesn't need a special right-click action, it erases on left click.
        for r in range(min(r1, r2), max(r1, r2) + 1):
            for c in range(min(c1, c2), max(c1, c2) + 1):
                pos = (r, c)
                # Right-click removes properties associated with active non-exclusive modes
                if is_color: self.cell_colors.pop(pos, None)
                if is_number: self.cell_numbers.pop(pos, None)
                if is_socket: self.sockets.discard(pos) # Remove socket on right-click if socket mode is active
                
        self.drag_start_right = None
        self.draw_all()
        self._recompute_all()

    def update_drag_rect(self, e, left_click=True):
        start = self.drag_start if left_click else self.drag_start_right
        if not start: return
        cell = self.xy_to_cell(e.x, e.y)
        if not cell: return
        rect_id = self.drag_rect_id if left_click else self.drag_rect_id_right
        if rect_id: self.canvas.delete(rect_id)
        r1, c1 = start
        r2, c2 = cell
        x1, y1, _, _ = self.cell_to_xy(min(r1, r2), min(c1, c2))
        _, _, x2, y2 = self.cell_to_xy(max(r1, r2), max(c1, c2))
        outline_color = "#3B82F6" if left_click else "#EF4444"
        new_rect_id = self.canvas.create_rectangle(x1, y1, x2, y2, outline=outline_color, width=2, dash=(4, 2))
        if left_click: self.drag_rect_id = new_rect_id
        else: self.drag_rect_id_right = new_rect_id

    def refresh_list(self):
        sel = self.items_list.curselection()
        self.items_list.delete(0, tk.END)
        for i, it in enumerate(self.items, 1):
            self.items_list.insert(tk.END, self.item_label(it, i))
        if sel: self.items_list.selection_set(sel[0])
        self._update_insert_spin_range()
        self._recompute_all()

    # Insert Section GUI가 제거되었으므로, 관련 함수는 내부 로직으로만 사용됨
    def _update_insert_spin_range(self):
        total = len(self.items) + 1
        # self.pos_spin.config(to=total) # Spinbox 제거됨

    def item_label(self, it, idx):
        if isinstance(it, SectionHeader): return f"[Section] {it.title}"
        b: Block = it
        label = f"Hatch:{b.hatch}" if b.hatch else (f"Hold:{b.hold}" if b.hold else "-")
        return f"Block {idx} — {b.rows}x{b.cols} | {label} Bay:{b.bay or '-'} Deck:{b.deck or '-'} | Nums:{len(b.cell_numbers)}"

    def _write_gang_counts(self, counts):
        for g in range(3, 10): self.gang_vars[g].set(str(counts.get(g, 0)))

    def edit_selected(self, event=None):
        sel = self.items_list.curselection()
        if not sel:
            messagebox.showinfo("Info", "편집할 블럭을 선택하세요.")
            return
        idx = sel[0]
        it = self.items[idx]
        if isinstance(it, SectionHeader): return

        self.editing_index = idx
        b: Block = it
        self.rows, self.cols = b.rows, b.cols
        self.cell_colors, self.cell_numbers, self.sockets = dict(b.cell_colors), dict(b.cell_numbers), set(b.sockets)
        self._write_gang_counts(b.gang_counts)
        
        if b.rows >= 6:
            self.meta_label_type.set("Hold No")
            self.meta_no.set(b.hold)
        else:
            self.meta_label_type.set("Hatch No")
            self.meta_no.set(b.hatch)
            
        self.meta_bay.set(b.bay); self.meta_deck.set(b.deck)
        self.draw_all()
        self.winfo_toplevel().title("Reefer Layout [EDITING]")

    def save_edits(self):
        self._save_state_for_undo()
        if self.editing_index is None: return
        b: Block = self.items[self.editing_index]
        b.cell_colors, b.cell_numbers, b.sockets = dict(self.cell_colors), dict(self.cell_numbers), set(self.sockets)
        b.gang_counts = {g: int(self.gang_vars[g].get() or 0) for g in range(3, 10)}
        self.refresh_list()
        self.editing_index = None
        self.winfo_toplevel().title("Reefer Layout")
        messagebox.showinfo("Saved", "블럭 수정이 저장되었습니다.")

    # 우클릭 메뉴 이벤트 핸들러 추가
    def _show_context_menu(self, event):
        # 마우스 위치의 항목을 선택
        try:
            index = self.items_list.nearest(event.y)
            if index is not None:
                self.items_list.selection_clear(0, tk.END)
                self.items_list.selection_set(index)
                # 메뉴 표시
                self.context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.context_menu.grab_release()

    # 우클릭 메뉴 액션 핸들러 추가 (삭제 및 삽입 통합)
    def context_menu_action(self, action: str):
        sel = self.items_list.curselection()
        if not sel: 
            if action.startswith("INSERT_"):
                # 아무것도 선택되지 않았을 경우, 맨 마지막에 삽입
                self.insert_section_at(action.replace("INSERT_", ""), pos=len(self.items))
            return
            
        idx = sel[0]
        
        if action == "DELETE":
            # 삭제 로직 (Delete Block)
            it = self.items[idx]
            if isinstance(it, SectionHeader):
                 confirm_msg = f"정말로 선택한 섹션({it.title})를 삭제하시겠습니까?"
            else:
                 confirm_msg = "정말로 선택한 블럭을 삭제하시겠습니까?"

            if messagebox.askyesno("Confirm", confirm_msg):
                self._save_state_for_undo()
                del self.items[idx]
                self.refresh_list()
        elif action.startswith("INSERT_"):
            # 삽입 로직 (선택된 항목의 바로 다음 위치에 삽입)
            self.insert_section_at(action.replace("INSERT_", ""), pos=idx + 1)
            

    def apply_meta_to_selected(self):
        sel = self.items_list.curselection()
        if not sel: return
        self._save_state_for_undo()
        b: Block = self.items[sel[0]]
        if self.meta_label_type.get() == "Hold No": b.hold, b.hatch = self.meta_no.get(), ""
        else: b.hatch, b.hold = self.meta_no.get(), ""
        b.bay, b.deck = self.meta_bay.get(), self.meta_deck.get()
        self.refresh_list()

    # Insert Section GUI 제거로 pos 파라미터를 추가하여 우클릭 메뉴에서 사용하도록 수정
    def insert_section_at(self, title: str, pos: Optional[int] = None):
        self._save_state_for_undo()
        if pos is None:
            # GUI가 제거되었으므로 이 경로는 사용되지 않지만, 기존 코드 호환을 위해 남김
            try: pos = int(self.insert_pos.get()) - 1
            except (ValueError, TypeError): pos = len(self.items)
        
        insert_idx = min(max(0, pos), len(self.items))
        self.items.insert(insert_idx, SectionHeader(title=title))
        self.refresh_list()

    def import_from_excel(self):
        path = filedialog.askopenfilename(filetypes=[("Excel", "*.xlsx *.xlsm")])
        if not path: return
        self._save_state_for_undo()
        try:
            wb = load_workbook(path, data_only=True)
            ws = wb.active
        except Exception as e:
            messagebox.showerror("Error", f"파일 열기 실패:\n{e}")
            return

        added, skipped = 0, 0
        # 요청에 따라 Import 시 기본 색상을 회색으로 복원
        default_fill_color = "#EEEEEE" 
        
        for row in ws.iter_rows(min_row=1, values_only=True):
            if not row or len(row) < 2 or row[0] is None or row[1] is None: continue
            try:
                values = [int(p.strip()) for p in str(row[1]).replace("，", ",").split(",") if p.strip()]
                if not values: raise ValueError
                rows, cols = len(values), max(values)
                
                b = Block(rows=rows, cols=cols)
                if rows >= 6:
                    b.hold = str(row[0]).strip()
                else:
                    b.hatch = str(row[0]).strip()
                    
                for r_idx, cnt in enumerate(values, 1):
                    start_c = 1 + (cols - cnt) // 2
                    for k in range(cnt): b.cell_colors[(r_idx, start_c + k)] = default_fill_color
                self.items.append(b)
                added += 1
            except:
                skipped += 1
        self.refresh_list()
        messagebox.showinfo("Import", f"완료: {added}개 블럭 추가, {skipped}행 무시")

    def export_excel(self):
        if not self.items: return
        path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")])
        if path:
            try:
                write_excel(
                    self.items, 
                    path, 
                    self.ship_no.get(), 
                    self.looking_txt.get(),
                    self.rs_count.get(),
                    self.rd_per_rs.get()
                )
                messagebox.showinfo("Exported", f"파일 저장 완료:\n{path}")
            except Exception as e:
                messagebox.showerror("Error", f"저장 실패:\n{e}")

    # =================================================================
    # Auto Set 그룹 (메인 로직)
    # =================================================================
    def auto_set_groups(self):
        self._save_state_for_undo()
        sel = self.items_list.curselection()
        targets = [self.items[sel[0]]] if sel and isinstance(self.items[sel[0]], Block) else [it for it in self.items if isinstance(it, Block)]
        if not targets:
            messagebox.showinfo("Auto Set", "대상 블럭이 없습니다.")
            return

        cap = simpledialog.askinteger("Auto Set", "RD panel 당 최대 컨테이너 수", minvalue=4, maxvalue=9999, parent=self)
        if cap is None: return 

        try:
            rs_total = int(self.rs_count.get() or 0)
            rpr = int(self.rd_per_rs.get() or 0)
        except(ValueError, TypeError):
            rs_total, rpr = 0, 0
            
        even_list, odd_list = _build_rd_queues(rs_total, rpr)

        # PASS 1
        all_left_placements = []
        all_right_placements = []
        total_left_cells = 0
        total_right_cells = 0
        any_failure = False

        for b in targets:
            b.cell_numbers.clear() 
            b.gang_counts = {g: 0 for g in range(3, 10)}

            unfilled_cells = {p for p, color in b.cell_colors.items()}
            
            center_col = (b.cols + 1) / 2.0
            left_active = {p for p in unfilled_cells if p[1] < center_col}
            right_active = {p for p in unfilled_cells if p[1] > center_col}
            center_cells = {p for p in unfilled_cells if p[1] == center_col}

            if len(left_active) <= len(right_active):
                left_active.update(center_cells)
            else:
                right_active.update(center_cells)

            placements = [] 
            success = False
            if b.rows >= 6:
                success = self._solve_line_tiling(b, left_active, "LEFT", placements) and \
                          self._solve_line_tiling(b, right_active, "RIGHT", placements)
            else:
                right_placements, left_placements = [], []
                if self._solve_tiling_recursive(b, right_active, "RIGHT", right_placements):
                    if self._solve_tiling_recursive(b, left_active, "LEFT", left_placements):
                        placements = right_placements + left_placements
                        success = True

            if not success:
                messagebox.showerror("배치 실패", f"블록 {b.hatch or b.hold or '(번호 없음)'}에서 빈 칸 없이 모든 공간을 채우는 조합을 찾지 못했습니다.\n블록 모양을 확인해주세요.")
                any_failure = True
                continue

            left_placements_b = [p for p in placements if p['side'] == 'LEFT']
            right_placements_b = [p for p in placements if p['side'] == 'RIGHT']

            left_placements_b.sort(key=lambda p: (min(r for r,c in p['cells']), min(c for r,c in p['cells'])))
            right_placements_b.sort(key=lambda p: (min(r for r,c in p['cells']), -max(c for r,c in p['cells'])))

            for p in left_placements_b:
                all_left_placements.append( (b, p) ) 
                total_left_cells += p['size']
                
            for p in right_placements_b:
                all_right_placements.append( (b, p) ) 
                total_right_cells += p['size']

        if any_failure:
            return

        # PASS 2
        target_counts_even = {} 
        rd_remaining_even = {rd: cap for rd in even_list} 
        total_even_rds = len(even_list)
        if total_even_rds > 0 and total_left_cells > 0:
            avg_cap_even = total_left_cells // total_even_rds 
            rem_even = total_left_cells % total_even_rds     
            for i, rd in enumerate(even_list):
                target_counts_even[rd] = avg_cap_even + (1 if i < rem_even else 0)
        
        target_counts_odd = {} 
        rd_remaining_odd = {rd: cap for rd in odd_list} 
        total_odd_rds = len(odd_list)
        if total_odd_rds > 0 and total_right_cells > 0:
            avg_cap_odd = total_right_cells // total_odd_rds 
            rem_odd = total_right_cells % total_odd_rds     
            for i, rd in enumerate(odd_list):
                target_counts_odd[rd] = avg_cap_odd + (1 if i < rem_odd else 0)

        cur_even = [0] 
        for (b, p) in all_left_placements: 
            need = p['size'] 
            cells = p['cells'] 
            assigned_rd = self._rd_take_v10(need, target_counts_even, rd_remaining_even, even_list, cur_even)
            if assigned_rd is not None:
                color = self._pick_color(cells, b)
                for cell in cells:
                    b.cell_numbers[cell] = assigned_rd
                    b.cell_colors[cell] = color
                b.gang_counts[need] = b.gang_counts.get(need, 0) + 1

        cur_odd = [0] 
        for (b, p) in all_right_placements: 
            need = p['size'] 
            cells = p['cells'] 
            assigned_rd = self._rd_take_v10(need, target_counts_odd, rd_remaining_odd, odd_list, cur_odd)
            if assigned_rd is not None:
                color = self._pick_color(cells, b)
                for cell in cells:
                    b.cell_numbers[cell] = assigned_rd
                    b.cell_colors[cell] = color
                b.gang_counts[need] = b.gang_counts.get(need, 0) + 1

        if self.editing_index is not None: self.edit_selected() 
        self.refresh_list() 
        self._recompute_all() 
        messagebox.showinfo("Auto Set", "자동 배치 완료")

    def _solve_line_tiling(self, b: Block, side_active: Set[Cell], side: str, placements: List[Dict]) -> bool:
        def partition(length: int) -> Optional[List[int]]:
            sizes = sorted([s for s in SHAPE_LIBRARY.keys() if s <= length], reverse=True)
            memo = {}
            def find(rem_len):
                if rem_len == 0: return []
                if rem_len < 4 : return None
                if rem_len in memo: return memo[rem_len]
    
                for size in sizes:
                    if size <= rem_len:
                        res = find(rem_len - size)
                        if res is not None:
                            memo[rem_len] = [size] + res
                            return memo[rem_len]
                memo[rem_len] = None
                return None
            return find(length)

        rows = sorted(list({r for r, c in side_active}))
        for r in rows:
            cols_in_row = sorted([c for r_c, c in side_active if r_c == r])
            if not cols_in_row: continue
            spans = []
            start = cols_in_row[0]
            for i in range(1, len(cols_in_row)):
                if cols_in_row[i] != cols_in_row[i-1] + 1:
                    spans.append((start, cols_in_row[i-1]))
                    start = cols_in_row[i]
            spans.append((start, cols_in_row[-1]))
            
            for start_col, end_col in spans:
                span_len = end_col - start_col + 1
                pieces = partition(span_len)
                if pieces is None: return False
                ptr = start_col
                for size in pieces:
                    cells = {(r, c) for c in range(ptr, ptr + size)}
                    placements.append({'size': size, 'cells': cells, 'side': side})
                    ptr += size
        return True

    def _solve_tiling_recursive(self, b: Block, unfilled: Set[Cell], side: str, placements: List[Dict]) -> bool:
        if not unfilled:
            return True

        is_left = (side == "LEFT")
        start_cell = min(unfilled, key=lambda p: (p[0], p[1] if is_left else -p[1]))

        priority_sizes = [9, 7, 8, 6, 5, 4]
        
        for size in priority_sizes:
            for shape_pattern in SHAPE_LIBRARY.get(size, []):
                shape_height = max(r_off for r_off, c_off in shape_pattern) + 1
                shape_width = max(c_off for r_off, c_off in shape_pattern) + 1
                if shape_height == 1 or shape_width == 1:
                    continue 

                group_cells = {(start_cell[0] + r_off, start_cell[1] + (c_off if is_left else -c_off))
                               for r_off, c_off in shape_pattern}

                if group_cells.issubset(unfilled):
                    placements.append({'size': size, 'cells': group_cells, 'side': side})
                    if self._solve_tiling_recursive(b, unfilled - group_cells, side, placements):
                        return True
                    placements.pop()

        for size in priority_sizes:
            for shape_pattern in SHAPE_LIBRARY.get(size, []):
                shape_height = max(r_off for r_off, c_off in shape_pattern) + 1
                shape_width = max(c_off for r_off, c_off in shape_pattern) + 1
                if not (shape_height == 1 or shape_width == 1):
                    continue

                group_cells = {(start_cell[0] + r_off, start_cell[1] + (c_off if is_left else -c_off))
                                       for r_off, c_off in shape_pattern}
                if not group_cells.issubset(unfilled): 
                    continue

                remaining_unfilled = unfilled - group_cells
                is_isolated = True
                for r_cell, c_cell in group_cells:
                    if (r_cell - 1, c_cell) in remaining_unfilled or (r_cell + 1, c_cell) in remaining_unfilled:
                        is_isolated = False
                        break
                
                if not is_isolated:
                    continue

                placements.append({'size': size, 'cells': group_cells, 'side': side})
                if self._solve_tiling_recursive(b, unfilled - group_cells, side, placements):
                    return True
                placements.pop()

        return False

    def _rd_take_v10(self, need, target_counts, rd_remaining, rds, cursor):
        n = len(rds)
        if n == 0: return None
        
        current_idx = cursor[0] 
        while current_idx < n:
            current_rd = rds[current_idx]
            can_fit = rd_remaining.get(current_rd, 0) >= need
            below_target = target_counts.get(current_rd, 0) > 0 
        
            if can_fit and below_target:
                rd_remaining[current_rd] -= need
                target_counts[current_rd] = target_counts.get(current_rd, 0) - need 
                cursor[0] = current_idx
                return current_rd
            current_idx += 1 
            
        for i in range(n): 
            check_idx = i 
            check_rd = rds[check_idx]
            if rd_remaining.get(check_rd, 0) >= need:
                rd_remaining[check_rd] -= need
                target_counts[check_rd] = target_counts.get(check_rd, 0) - need 
                cursor[0] = check_idx
                return check_rd
                
        return None

    def _pick_color(self, cells, b):
        # 요청에 따라 사용자가 지정한 4가지 색상만 사용하도록 수정
        palette = self.FIXED_COLORS 
        
        adj_colors = set()
        for r, c in cells:
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: 
                adj_cell = (r + dr, c + dc)
                if adj_cell in b.cell_colors: 
                    adj_colors.add(b.cell_colors[adj_cell]) 
        
        # 인접 셀과 다른 색상 중 첫 번째를 선택
        for color in palette:
            if color not in adj_colors:
                return color
        
        # 만약 4가지 색상 모두 인접해 있다면, 지정된 색상 중 첫 번째 색상을 반환 (fallback)
        return palette[0]


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Reefer Layout")
        try:
            from ctypes import windll; windll.shcore.SetProcessDpiAwareness(1)
        except: pass
        self.geometry("1400x950") 
        self.minsize(1200, 800) 
        GridCanvas(self) 

if __name__ == '__main__':
    app = App() 
    app.mainloop()

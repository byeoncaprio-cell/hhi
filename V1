import tkinter as tk
from tkinter import ttk, messagebox, filedialog, colorchooser, simpledialog
from typing import Set, Tuple, List, Dict, Union, Optional
from dataclasses import dataclass, field
from collections import Counter, OrderedDict
import random
import copy

from openpyxl import Workbook, load_workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side, Font
from openpyxl.utils import get_column_letter
from openpyxl.cell import Cell # Excel 수식 입력을 위해 추가

# --------------------------------
# Types & Models
# --------------------------------
Cell = Tuple[int, int]  # (row, col) 1-based

@dataclass
class Block:
    rows: int
    cols: int
    hatch: str = ""
    hold: str = ""
    bay: str = ""
    deck: str = ""
    cell_colors: Dict[Cell, str] = field(default_factory=dict)
    cell_numbers: Dict[Cell, Union[int, float, str]] = field(default_factory=dict)
    sockets: Set[Cell] = field(default_factory=set)
    gang_counts: Dict[int, int] = field(default_factory=dict)

@dataclass
class SectionHeader:
    title: str

Item = Union[Block, SectionHeader]


# --------------------------------
# Shape Library for Auto-Set
# --------------------------------
SHAPE_LIBRARY: Dict[int, List[List[Cell]]] = {
    9: [
        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)],  # 3x3
        [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3)],
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4)],
        [(0, 1), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (4, 1)],
        [(0, 0), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1)],
        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)],
        [(0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4)],
        [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 1), (1, 2), (1, 3), (1, 4)],
    ],
    8: [
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)],  # 2x4
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],  # 4x2
    ],
    7: [
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2)],
        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (1, 3)],
        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 1)],
        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3)],
        [(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)],
        [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0)],
    ],
    6: [
        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)],  # 2x3
        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)],  # 3x2
    ],
    5: [
        [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)],  # 1x5
        [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],  # 5x1
    ],
    4: [
        [(0, 0), (0, 1), (1, 0), (1, 1)],  # 2x2
    ],
}
# --------------------------------
# Utils
# --------------------------------
def parse_number_like(s: str) -> Union[int, float, str]:
    try:
        if str(s).strip() == "": return ""
        if "." in str(s):
            f = float(s)
            return int(f) if f.is_integer() else f
        return int(s)
    except (ValueError, TypeError):
        return s

def header_sequence(n: int) -> List[int]:
    evens = [x for x in range(n, 0, -1) if x % 2 == 0]
    odds = list(range(1, n + 1, 2))
    return evens + odds

def set_range_border(ws, min_row, max_row, min_col, max_col, side_top, side_right, side_bottom, side_left):
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            cell = ws.cell(row=r, column=c)
            current_border = cell.border
            new_border = Border(
                top=side_top if r == min_row else current_border.top,
                bottom=side_bottom if r == max_row else current_border.bottom,
                left=side_left if c == min_col else current_border.left,
                right=side_right if c == max_col else current_border.right
            )
            cell.border = new_border

def thick_column_positions(max_grid_cols: int) -> List[int]:
    if max_grid_cols <= 0: return []
    seq = header_sequence(max_grid_cols)
    try:
        boundary_col = seq.index(1) + 1
    except ValueError:
        return []
    pos = {x for x in range(boundary_col, max_grid_cols + 1, 4)}
    pos.update({x for x in range(boundary_col - 4, 0, -4)})
    return sorted(list(pos))

def safe_sheet_title(s: str) -> str:
    invalid_chars = r'[]:*?/\ '
    clean_s = "".join(c if c not in invalid_chars else '-' for c in (s or "Sheet"))
    return clean_s[:31]

# --- [Refactored Helper Functions] ---
# (Moved from GridCanvas class)

def _collect_rd_counts(items: List[Item]) -> OrderedDict:
    """RD 번호별 총 개수를 집계합니다. (GUI용)"""
    c = Counter(int(v) for it in items if isinstance(it,Block) for v in it.cell_numbers.values() if str(v).strip())
    return OrderedDict(sorted(c.items()))

def _rd_list_for_rs(rs_index, rd_per_rs):
    """특정 RS 패널에 할당된 RD 번호 리스트를 반환합니다."""
    if rd_per_rs <= 0 or rs_index <= 0: return []
    if rs_index % 2 == 1:
        # STBD (Odd)
        block_idx = (rs_index - 1) // 2
        start_odd = 1 + 2 * (block_idx * rd_per_rs)
        return [start_odd + 2*i for i in range(rd_per_rs)]
    else:
        # PORT (Even)
        block_idx = (rs_index // 2) - 1
        start_even = 2 + 2 * (block_idx * rd_per_rs)
        return [start_even + 2*i for i in range(rd_per_rs)]

def _build_rd_queues(rs_total, rpr):
    """PORT(Even)와 STBD(Odd)의 RD 대기열을 생성합니다."""
    even_q, odd_q = [], []
    for rs in range(1, rs_total + 1):
        (even_q if rs % 2 == 0 else odd_q).extend(_rd_list_for_rs(rs, rpr))
    return sorted(list(set(even_q))), sorted(list(set(odd_q)))

def _build_rs_summary(rs_indices, rd_counts, rpr):
    """GUI의 Live Summary 텍스트를 생성합니다."""
    lines = []
    for rs in rs_indices:
        rd_list = _rd_list_for_rs(rs, rpr)
        total = sum(rd_counts.get(rd, 0) for rd in rd_list)
        lines.append(f"RS-{rs}: total {total}")
        lines.extend([f"  RD-{rd}: {rd_counts[rd]}" for rd in rd_list if rd_counts.get(rd, 0) > 0])
        if not any(rd_counts.get(rd, 0) > 0 for rd in rd_list):
            lines.append("  -")
        lines.append("")
    return "\n".join(lines).rstrip()

# --- [End Refactored Helper Functions] ---


# --------------------------------
# Excel Writer
# --------------------------------
def write_excel(
    items: List[Item],
    filename: str,
    ship_no: str,
    looking_text: str = "LOOKING TO FWD",
    rs_count_str: str = "0",
    rd_per_rs_str: str = "0",
    row_gap_between_blocks: int = 2,
    info_cols: int = 1, gap_after_info: int = 1,
    deck_cols: int = 1, gap_after_deck: int = 1
):
    if not items:
        raise ValueError("No content to export. Add blocks or section headers.")

    block_cols = [it.cols for it in items if isinstance(it, Block)]
    max_grid_cols = max(block_cols) if block_cols else 6

    grid_start_col = info_cols + gap_after_info + deck_cols + gap_after_deck + 1
    grid_right_col = grid_start_col + max_grid_cols - 1

    qty_col = grid_right_col + 3
    gang_gap_col = qty_col + 1
    g_start_col = qty_col + 2
    g_cols = {g: g_start_col + (g - 3) for g in range(3, 10)}
    g_sum_col = g_start_col + 7

    wb = Workbook()
    ws = wb.active
    
    sheet_name = safe_sheet_title(ship_no)
    ws.title = sheet_name

    align_center = Alignment(horizontal="center", vertical="center")
    align_right  = Alignment(horizontal="right",  vertical="center")
    thin  = Side(style="thin", color="000000")
    thick = Side(style="thick", color="000000")
    dashed_med = Side(style="mediumDashed", color="000000")
    border_thin  = Border(left=thin, right=thin, top=thin, bottom=thin)
    gray_fill = PatternFill("solid", fgColor="EEEEEE")

    for c in range(1, g_sum_col + 2): ws.column_dimensions[get_column_letter(c)].width = 4
    for c in range(1, info_cols + 1): ws.column_dimensions[get_column_letter(c)].width = 10
    ws.column_dimensions[get_column_letter(info_cols + 1)].width = 2
    for c in range(info_cols + 2, info_cols + 2 + deck_cols): ws.column_dimensions[get_column_letter(c)].width = 4
    ws.column_dimensions[get_column_letter(info_cols + 2 + deck_cols)].width = 2

    from openpyxl.utils import get_column_letter as _g
    ws.column_dimensions[_g(qty_col - 2)].width = 4
    ws.column_dimensions[_g(qty_col - 1)].width = 5
    ws.column_dimensions[_g(qty_col)].width     = 4
    ws.column_dimensions[_g(gang_gap_col)].width= 2
    for g in range(3, 10): ws.column_dimensions[_g(g_cols[g])].width = 4
    ws.column_dimensions[_g(g_sum_col)].width   = 7

    title_text = (ship_no.strip() + " Reefer Arrangement") if ship_no.strip() else "Reefer Arrangement"
    try:
        ws.oddHeader.center.text = f"&B&11{title_text}"
        ws.oddHeader.right.text  = f"&B&11{(looking_text or 'LOOKING TO FWD')}"
    except Exception:
        pass

    left_end = max(1, grid_right_col - 4)
    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=left_end)
    tcell = ws.cell(row=1, column=1, value=title_text)
    tcell.alignment = align_center; tcell.font = Font(size=11, bold=True)
    set_range_border(ws, 1, 1, 1, left_end, thick, thick, thick, thick)

    right_start = left_end + 1
    ws.merge_cells(start_row=1, start_column=right_start, end_row=1, end_column=grid_right_col)
    rcell = ws.cell(row=1, column=right_start, value=(looking_text or "LOOKING TO FWD"))
    rcell.alignment = align_center; rcell.font = Font(size=10)
    set_range_border(ws, 1, 1, right_start, grid_right_col, thick, thick, thick, thick)

    cur_row = 3

    seq = header_sequence(max_grid_cols)
    for i, val in enumerate(seq, start=0):
        cc = grid_start_col + i
        ws.cell(row=cur_row, column=cc, value=int(val)).alignment = align_center
        ws.cell(row=cur_row, column=cc).font = Font(size=9, bold=True)

    ws.merge_cells(start_row=cur_row+1, start_column=g_cols[3], end_row=cur_row+1, end_column=g_sum_col)
    gtitle = ws.cell(row=cur_row+1, column=g_cols[3], value="gang별 수량")
    gtitle.alignment = align_center; gtitle.font = Font(size=9, bold=True)
    for c in range(g_cols[3], g_sum_col + 1):
        ws.cell(row=cur_row+1, column=c).fill = gray_fill

    hrow = cur_row + 2
    ws.cell(row=hrow, column=qty_col, value="Q'ty").alignment = align_center
    for g in range(3, 10):
        hc = ws.cell(row=hrow, column=g_cols[g], value=g)
        hc.alignment = align_center; hc.fill = gray_fill
    sm = ws.cell(row=hrow, column=g_sum_col, value="SUM")
    sm.alignment = align_center; sm.fill = gray_fill

    cur_row = hrow + 1
    data_start_row = cur_row 
    
    vertical_thick_cols = set(thick_column_positions(max_grid_cols))
    last_used_row = cur_row
    grand_qty_ranges = []
    gang_summary_rows = []

    count_left_letter  = get_column_letter(grid_start_col)
    count_right_letter = get_column_letter(grid_start_col + max_grid_cols - 1)

    for it in items:
        if isinstance(it, SectionHeader):
            ws.merge_cells(start_row=cur_row, start_column=grid_start_col, end_row=cur_row, end_column=grid_right_col)
            scell = ws.cell(row=cur_row, column=grid_start_col, value=it.title)
            scell.alignment = align_center; scell.font = Font(size=24, bold=True)
            set_range_border(ws, cur_row, cur_row, grid_start_col, grid_right_col, dashed_med, dashed_med, dashed_med, dashed_med)
            cur_row += 4
            last_used_row = max(last_used_row, cur_row - 1) # 갱신
            continue

        b: Block = it
        label_text = f"Hatch No. {b.hatch}" if b.hatch else (f"Hold No. {b.hold}" if b.hold else " ")
        ws.cell(row=cur_row, column=1, value=label_text).alignment = align_center
        ws.cell(row=cur_row, column=1).font = Font(size=8, color="C00000")
        set_range_border(ws, cur_row, cur_row, 1, 1, thin, thin, thin, thin)

        bay_text = f"Bay {b.bay}" if b.bay else " "
        ws.cell(row=cur_row + 1, column=1, value=bay_text).alignment = align_center
        ws.cell(row=cur_row + 1, column=1).font = Font(size=8, color="C00000")
        set_range_border(ws, cur_row + 1, cur_row + 1, 1, 1, thin, thin, thin, thin)

        deck_text = b.deck if b.deck else " "
        ws.cell(row=cur_row, column=info_cols + gap_after_info + 1, value=deck_text).alignment = align_center
        ws.cell(row=cur_row, column=info_cols + gap_after_info + 1).font = Font(size=8, color="C00000")

        left_offset = (max_grid_cols - b.cols) // 2
        block_start_row = cur_row
        block_end_row   = cur_row + b.rows - 1
        grand_qty_ranges.append((block_start_row, block_end_row))

        for r in range(1, b.rows + 1):
            rr = cur_row + r - 1
            ws.row_dimensions[rr].height = 18 
            for c in range(1, b.cols + 1):
                global_grid_col = left_offset + c
                cc = grid_start_col + global_grid_col - 1
                cell = ws.cell(row=rr, column=cc)
                cell.alignment = align_center
                if (r,c) in b.cell_colors: cell.fill = PatternFill("solid", fgColor=b.cell_colors[(r,c)].lstrip("#"))
                cell.border = border_thin
                if (r,c) in b.cell_numbers: cell.value = parse_number_like(b.cell_numbers[(r,c)])
                if (r,c) in b.sockets: cell.border = Border(left=Side(style="thick", color="FF0000"), right=Side(style="thick", color="FF0000"), top=Side(style="thick", color="FF0000"), bottom=Side(style="thick", color="FF0000"))
                if global_grid_col in vertical_thick_cols: cell.border = Border(left=thick, right=cell.border.right, top=cell.border.top, bottom=cell.border.bottom)

            ws.cell(row=rr, column=qty_col, value=f"=COUNT({count_left_letter}{rr}:{count_right_letter}{rr})").alignment = align_center
            ws.cell(row=rr, column=qty_col).font = Font(size=8)
            ws.cell(row=rr, column=gang_gap_col).fill = gray_fill
            for g in range(3, 10): ws.cell(row=rr, column=g_cols[g]).fill = gray_fill
            ws.cell(row=rr, column=g_sum_col).fill = gray_fill

        sum_row = block_end_row + 1
        gang_summary_rows.append(sum_row)
        qcol_letter = get_column_letter(qty_col)
        total_cell = ws.cell(row=sum_row, column=qty_col, value=f"=SUM({qcol_letter}{block_start_row}:{qcol_letter}{block_end_row})")
        total_cell.alignment = align_center; total_cell.font = Font(size=8, bold=True)
        total_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)

        ws.cell(row=sum_row, column=gang_gap_col).fill = gray_fill
        terms = []
        for g in range(3, 10):
            cnt = int(b.gang_counts.get(g, 0) or 0)
            cell = ws.cell(row=sum_row, column=g_cols[g], value=cnt)
            cell.alignment = align_center; cell.font = Font(size=8); cell.fill = gray_fill
            terms.append(f"{g}*{get_column_letter(g_cols[g])}{sum_row}")

        gsum_cell = ws.cell(row=sum_row, column=g_sum_col, value="=" + "+".join(terms))
        gsum_cell.alignment = align_center; gsum_cell.font = Font(size=8, bold=True); gsum_cell.fill = gray_fill

        cur_row += max(b.rows, 2) + row_gap_between_blocks
        last_used_row = max(last_used_row, cur_row - 1) # 갱신

    grand_row = last_used_row + 2
    ws.cell(row=grand_row, column=(qty_col - 1), value="Total").alignment = align_right; ws.cell(row=grand_row, column=(qty_col-1)).font = Font(size=9, bold=True)
    parts = [f"{get_column_letter(qty_col)}{s}:{get_column_letter(qty_col)}{e}" for s, e in grand_qty_ranges]
    grand_qty_cell = ws.cell(row=grand_row, column=qty_col, value=f"=SUM({','.join(parts)})")
    grand_qty_cell.alignment = align_center; grand_qty_cell.font = Font(size=9, bold=True)
    grand_qty_cell.border = Border(top=thick, left=thin, right=thin, bottom=thin)

    gang_total_row = grand_row + 2
    ws.cell(row=gang_total_row, column=g_cols[3]-2, value="Total Gangs:").alignment = align_right
    ws.cell(row=gang_total_row, column=g_cols[3]-2).font = Font(bold=True)
    for g in range(3, 10):
        col_letter = get_column_letter(g_cols[g])
        sum_parts = [f"{col_letter}{r}" for r in gang_summary_rows]
        cell = ws.cell(row=gang_total_row, column=g_cols[g], value=f"=SUM({','.join(sum_parts)})")
        cell.alignment = align_center; cell.font = Font(bold=True); cell.border = Border(top=thick, bottom=thick)

    for gcol in vertical_thick_cols:
        col_idx = grid_start_col + gcol - 1
        for r in range(data_start_row, last_used_row + 1): 
            cell = ws.cell(row=r, column=col_idx)
            cell.border = Border(left=thick, right=cell.border.right, top=cell.border.top, bottom=cell.border.bottom)

    # --- [START] Summary Sheet V5 Logic ---
    try:
        try: rs_total = int(rs_count_str or 0)
        except ValueError: rs_total = 0
        try: rpr = int(rd_per_rs_str or 0)
        except ValueError: rpr = 0
            
        data_range_str = (
            f"'{sheet_name}'!"
            f"{get_column_letter(grid_start_col)}{data_start_row}:"
            f"{get_column_letter(grid_right_col)}{last_used_row}"
        )
            
        summary_ws = wb.create_sheet(title="Summary")
        
        # 헬퍼 함수 _write_summary_sheet_v5 호출
        _write_summary_sheet_v5(
            summary_ws, 
            rs_total, 
            rpr, 
            data_range_str 
        )
    except Exception as e:
        print(f"Error creating summary sheet: {e}")
    # --- [END] Summary Sheet V5 Logic ---

    wb.save(filename)

# --------------------------------
# Summary Sheet Writer (V5 - Merged RS, No Grand Total, Smaller Font)
# --------------------------------
def _write_summary_sheet_v5(
    ws,
    rs_total: int,
    rpr: int,
    data_range_str: str # 메인 시트의 데이터 범위
):
    """
    (V5) RS/RD 병합, 폰트 축소, Grand Total 제거 + 추가 표 (행 제목 포함) 추가
    [USER MODIFIED] 
    - 표 1 (Cargo Hold Fans): 원본 레이아웃 유지 (가로: Data Headers, 세로: Row Titles)
    - 표 2 (Reefer Section): 행/열 전환 (가로: Row Titles, 세로: Data Headers(RS List))
    - [USER MODIFIED 2]
    - 오른쪽 표 2개의 '행 제목'을 '첫 번째 열의 데이터'로 이동 (셀 1칸씩 이동)
    - 오른쪽 표 2개의 열 너비를 더 '핏하게' 수정
    """

    from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
    from openpyxl.utils import get_column_letter
    from openpyxl.cell import Cell

    # --- 1. 스타일 정의 (폰트 축소) ---
    ws.font = Font(size=10) # 시트 기본 폰트 10

    bold_font = Font(size=10, bold=True)
    title_font = Font(size=13, bold=True) # 14 -> 13
    header_fill = PatternFill("solid", fgColor="DDEEFF") # RS/RD 헤더와 동일한 색상
    total_fill = PatternFill("solid", fgColor="F0F0F0")

    # 행 제목 및 데이터 제목에 사용할 스타일
    align_left_wrap = Alignment(horizontal="left", vertical="center", wrap_text=True) 
    align_right = Alignment(horizontal="right", vertical="center")
    align_center_wrap = Alignment(horizontal="center", vertical="center", wrap_text=True) 

    thin_side = Side(style="thin", color="000000")
    table_border = Border(left=thin_side, right=thin_side, top=thin_side, bottom=thin_side)

    # --- 2. 헤더 및 열 너비 설정 ---
    headers = ["RS", "RD", "REF. CON", "A", "BREAKER", "KVA"]
    col_widths = [8, 8, 8, 8, 12, 10]

    # --- 3. 테이블 작성 헬퍼 함수 ---
    def apply_styles(cell: Cell, font=None, fill=None, align=None, border=None, num_format=None):
        """셀에 스타일을 적용하는 헬퍼"""
        if font: cell.font = font
        if fill: cell.fill = fill
        if align: cell.alignment = align
        if border: cell.border = border
        if num_format: cell.number_format = num_format

    def set_column_widths(c_offset: int, widths: list):
        """지정된 오프셋에 열 너비를 설정합니다."""
        for i, width in enumerate(widths, 0):
            col_num = c_offset + i
            if col_num > 0:
                try:
                    ws.column_dimensions[get_column_letter(col_num)].width = width
                except ValueError: 
                    print(f"Warning: Invalid column number {col_num} for width setting.")
            else:
                print(f"Warning: Attempted to set width for non-positive column index {col_num}.")


    # [MODIFIED] process_rs_list (RS/RD 병합, Grand Total 반환값 제거)
    def process_rs_list(rs_list: list, s_row: int, c_offset: int) -> int:
        """
        지정된 RS 리스트에 대한 테이블을 그리고 수식을 채웁니다. (다음 시작 행) 반환
        """
        cur_row = s_row

        if rpr <= 0 or not rs_list:
            for i, h in enumerate(headers):
                apply_styles(ws.cell(cur_row, c_offset+i), border=table_border)
            ws.cell(cur_row, c_offset, "-")
            cur_row += 1
            return cur_row

        for rs in rs_list:
            rd_list = _rd_list_for_rs(rs, rpr)
            rs_start_row = cur_row

            if not rd_list:
                ws.merge_cells(start_row=cur_row, start_column=c_offset + 1, end_row=cur_row, end_column=c_offset + 5)
                rs_cell = ws.cell(cur_row, c_offset, f"RS-{rs}")
                apply_styles(rs_cell, font=bold_font, align=align_left_wrap, border=table_border)
                rd_cell = ws.cell(cur_row, c_offset + 1, "  (No RDs)")
                apply_styles(rd_cell, align=align_left_wrap, border=table_border)
                for i in range(2, 6):
                    apply_styles(ws.cell(cur_row, c_offset + i), border=table_border)
                cur_row += 1
                rs_start_row_for_sum = -1
            else:
                for rd in rd_list:
                    ref_con_cell_addr = f"{get_column_letter(c_offset + 2)}{cur_row}"
                    a_cell_addr = f"{get_column_letter(c_offset + 3)}{cur_row}"
                    apply_styles(ws.cell(cur_row, c_offset), border=table_border)
                    rd_cell = ws.cell(cur_row, c_offset + 1, f"  RD-{rd}")
                    apply_styles(rd_cell, align=align_left_wrap, border=table_border)
                    ref_cell = ws.cell(cur_row, c_offset + 2, value=f"=COUNTIF({data_range_str},{rd})")
                    apply_styles(ref_cell, align=align_right, border=table_border, num_format='0')
                    a_cell = ws.cell(cur_row, c_offset + 3, value=f"={ref_con_cell_addr}*17.4*0.9")
                    apply_styles(a_cell, align=align_right, border=table_border, num_format='0.00')
                    breaker_cell = ws.cell(cur_row, c_offset + 4, value=f'=IF({a_cell_addr}>=800,"1250/900",IF({a_cell_addr}>=700,"800/800","800/700"))')
                    apply_styles(breaker_cell, align=align_center_wrap, border=table_border)
                    kva_cell = ws.cell(cur_row, c_offset + 5, value=f"={ref_con_cell_addr}*10.6")
                    apply_styles(kva_cell, align=align_right, border=table_border, num_format='0.00')
                    cur_row += 1

                rs_end_row = cur_row - 1
                ws.merge_cells(start_row=rs_start_row, start_column=c_offset, end_row=rs_end_row, end_column=c_offset)
                rs_cell = ws.cell(rs_start_row, c_offset, f"RS-{rs}")
                apply_styles(rs_cell, font=bold_font, align=align_center_wrap, border=table_border)
                for r in range(rs_start_row + 1, rs_end_row + 1):
                    apply_styles(ws.cell(r, c_offset), border=table_border)
                rs_start_row_for_sum = rs_start_row

            spare_rows = 3
            for _ in range(spare_rows):
                for i in range(len(headers)):
                    apply_styles(ws.cell(cur_row, c_offset + i), border=table_border)
                cur_row += 1

            total_label_cell = ws.cell(row=cur_row, column=c_offset, value=f"RS-{rs} Total")
            apply_styles(total_label_cell, font=bold_font, align=align_left_wrap, fill=total_fill, border=table_border)
            apply_styles(ws.cell(cur_row, c_offset+1), fill=total_fill, border=table_border)

            if rs_start_row_for_sum == -1:
                ref_sum_formula, a_sum_formula, kva_sum_formula = 0, 0, 0
            else:
                rs_end_row_for_sum = cur_row - spare_rows - 1
                ref_sum_formula = f"=SUM({get_column_letter(c_offset+2)}{rs_start_row_for_sum}:{get_column_letter(c_offset+2)}{rs_end_row_for_sum})"
                a_sum_formula = f"=SUM({get_column_letter(c_offset+3)}{rs_start_row_for_sum}:{get_column_letter(c_offset+3)}{rs_end_row_for_sum})"
                kva_sum_formula = f"=SUM({get_column_letter(c_offset+5)}{rs_start_row_for_sum}:{get_column_letter(c_offset+5)}{rs_end_row_for_sum})"

            ref_total_cell = ws.cell(cur_row, c_offset + 2, value=ref_sum_formula)
            apply_styles(ref_total_cell, font=bold_font, align=align_right, fill=total_fill, border=table_border, num_format='0')
            a_total_cell = ws.cell(cur_row, c_offset + 3, value=a_sum_formula)
            apply_styles(a_total_cell, font=bold_font, align=align_right, fill=total_fill, border=table_border, num_format='0.00')
            apply_styles(ws.cell(cur_row, c_offset+4), fill=total_fill, border=table_border)
            kva_total_cell = ws.cell(cur_row, c_offset + 5, value=kva_sum_formula)
            apply_styles(kva_total_cell, font=bold_font, align=align_right, fill=total_fill, border=table_border, num_format='0.00')
            cur_row += 1

        return cur_row

    # --- 4. 메인 실행 ---

    port_col_offset = 1
    port_title = "PORT"
    even_rs = [i for i in range(1, rs_total + 1) if i % 2 == 0]

    stbd_col_offset = port_col_offset + len(col_widths) + 1
    stbd_title = "STBD"
    odd_rs  = [i for i in range(1, rs_total+1) if i % 2 == 1]

    set_column_widths(port_col_offset, col_widths)
    set_column_widths(stbd_col_offset, col_widths)
    ws.column_dimensions[get_column_letter(port_col_offset + len(col_widths))].width = 3 # Gap

    ws.merge_cells(start_row=1, start_column=port_col_offset, end_row=1, end_column=port_col_offset + len(headers) - 1)
    port_title_cell = ws.cell(row=1, column=port_col_offset, value=port_title)
    apply_styles(port_title_cell, font=title_font, align=align_center_wrap)

    ws.merge_cells(start_row=1, start_column=stbd_col_offset, end_row=1, end_column=stbd_col_offset + len(headers) - 1)
    stbd_title_cell = ws.cell(row=1, column=stbd_col_offset, value=stbd_title)
    apply_styles(stbd_title_cell, font=title_font, align=align_center_wrap)

    rs_rd_header_row = 2
    for i, h in enumerate(headers):
        port_h_cell = ws.cell(row=rs_rd_header_row, column=port_col_offset + i, value=h)
        apply_styles(port_h_cell, font=bold_font, fill=header_fill, align=align_center_wrap, border=table_border)

        stbd_h_cell = ws.cell(row=rs_rd_header_row, column=stbd_col_offset + i, value=h)
        apply_styles(stbd_h_cell, font=bold_font, fill=header_fill, align=align_center_wrap, border=table_border)

    data_start_row = rs_rd_header_row + 1

    port_next_row = process_rs_list(even_rs, data_start_row, port_col_offset)
    stbd_next_row = process_rs_list(odd_rs, data_start_row, stbd_col_offset)

    # --- [MODIFIED] 추가 표 (행 제목 포함) 작성 ---
    new_table_start_col = stbd_col_offset + len(headers) + 2

    # --- 표 1: Cargo Hold Fans (원본 레이아웃 유지) ---
    # 표 1의 행 제목 (세로 데이터)
    table1_row_titles = [
        "SIDE PASSGAEWAY(FWD)", "No.1A (Exp)", "No.2F (Exp)", "No.3F", "No.4F",
        "SIDE PASSAGEWAY(AFT)", "No.5F1", "No.5F2", "No.5A1", "No.5A2",
        "No.6F1", "No.6F2", "No.6A1", "No.6A2", "No.7F", "No.8F",
        "PIPE DUCT", "No.9F"
    ]
    # 표 1의 데이터 영역에 사용될 열 제목 (가로 헤더)
    table1_data_headers = [
        "Cargo hold (STBD)", "No. of C/Hold fans (STBD)", "Cargo hold(PORT)",
        "No. of C/Hold fans (PORT)", "Total No. of C/Hold fans",
        "C/Hold fan capacity (Rated, kW)", "Efficiency", "Load factor", "Div. factor",
        "Actual power consumption (kW)", "Actual power consumption(STBD, kW)",
        "Actual power consumption(PORT, kW)"
    ]
    
    # [FIX] 열 너비 '핏하게' 수정
    # 첫 번째 열 (헤더: "Cargo hold (STBD)", 데이터: "SIDE PASSGAEWAY(FWD)")
    table1_row_title_width = 28 
    # 나머지 데이터 열 (헤더 11개)
    table1_data_widths = [14] * (len(table1_data_headers) - 1)
    
    # 표1 시작 행 (RS/RD 헤더와 동일)
    table1_header_row = rs_rd_header_row 
    
    # 1. 첫 번째 열 너비 설정
    ws.column_dimensions[get_column_letter(new_table_start_col)].width = table1_row_title_width
    # 2. 나머지 데이터 열 너비 설정
    set_column_widths(new_table_start_col + 1, table1_data_widths)

    # 3. 데이터 열 헤더(가로 제목) 쓰기
    for i, header in enumerate(table1_data_headers):
        col_idx = new_table_start_col + i  # [FIX] +1 제거
        cell = ws.cell(row=table1_header_row, column=col_idx, value=header)
        apply_styles(cell, font=bold_font, fill=header_fill, align=align_center_wrap, border=table_border)

    # 4. 첫 번째 열 데이터 (구 '행 제목') 및 빈 데이터 셀 쓰기
    current_row = table1_header_row + 1 # 헤더 다음 줄부터 시작
    for title in table1_row_titles:
        # 첫 번째 열(new_table_start_col)에 데이터 쓰기
        cell = ws.cell(row=current_row, column=new_table_start_col, value=title)
        apply_styles(cell, align=align_left_wrap, border=table_border) # 세로 항목은 Bold 없음
        
        # [FIX] 해당 행의 '데이터' 열들에 테두리만 적용 (첫 열 제외)
        for i in range(len(table1_data_headers) - 1): # [FIX] -1 추가
             apply_styles(ws.cell(row=current_row, column=new_table_start_col + 1 + i), border=table_border)
        current_row += 1

    # --- 표 2: Reefer Section Board (행/열 전환) ---
    
    # (신) 가로 헤더 (기존 table2_row_titles)
    table2_horizontal_headers = [
        "Reefer Section board", "Ref. container(FEU)", "Reefer container(kVA)",
        "Cargo fan(kVA)", "Total capacity(kVA)", "TR capacity(kVA)"
    ]
    
    # (신) 세로 헤더 (데이터) (기존 table2_data_headers - 동적 RS 리스트)
    table2_vertical_headers = []
    if rs_total > 0:
        for i in range(1, rs_total + 1):
            suffix = "(S)" if i % 2 == 1 else "(P)"
            table2_vertical_headers.append(f"RS-{i}\n{suffix}")
            
    # [FIX] 열 너비 '핏하게' 수정
    # 첫 번째 열 (헤더: "Reefer Section board", 데이터: "RS-X")
    table2_vertical_header_width = 22
    # 나머지 데이터 열 (헤더 5개)
    table2_data_widths = [18] * (len(table2_horizontal_headers) - 1)

    # 표 1 데이터 영역 바로 아래 + 2줄 간격 시작
    table2_header_row = current_row + 2 

    # 1. 첫 번째 열 너비 설정
    ws.column_dimensions[get_column_letter(new_table_start_col)].width = table2_vertical_header_width
    # 2. 나머지 데이터 열 너비 설정 (표1과 너비가 다를 수 있으므로 재설정)
    set_column_widths(new_table_start_col + 1, table2_data_widths) 

    # 3. (신) 가로 헤더 (기존 Row Titles) 쓰기
    for i, header in enumerate(table2_horizontal_headers):
        col_idx = new_table_start_col + i # [FIX] +1 제거
        cell = ws.cell(row=table2_header_row, column=col_idx, value=header)
        apply_styles(cell, font=bold_font, fill=header_fill, align=align_center_wrap, border=table_border)
        
    # 4. (신) 세로 헤더 (데이터) (기존 Data Headers - RS 목록) 쓰기
    current_row = table2_header_row + 1 # 헤더 다음 줄부터 시작
    for title in table2_vertical_headers:
        # 첫 번째 열(new_table_start_col)에 (신) 세로 헤더 쓰기
        cell = ws.cell(row=current_row, column=new_table_start_col, value=title)
        # RS 목록은 세로/가운데 정렬 (개행 문자 \n 처리) 및 Bold
        apply_styles(cell, align=align_center_wrap, border=table_border, font=bold_font)
        
        # [FIX] 해당 행의 '데이터' 열들에 테두리만 적용 (첫 열 제외)
        for i in range(len(table2_horizontal_headers) - 1): # [FIX] -1 추가
             apply_styles(ws.cell(row=current_row, column=new_table_start_col + 1 + i), border=table_border)
        current_row += 1
    # --- [END MODIFIED] ---


# --------------------------------
# GUI
# --------------------------------
class GridCanvas(ttk.Frame):
    def __init__(self, master):
        super().__init__(master, padding=10)
        self.pack(fill="both", expand=True)

        self.rows, self.cols, self.cell_px = 4, 20, 22
        self.cell_colors, self.cell_numbers, self.sockets = {}, {}, set()
        self.paint_mode = tk.StringVar(value="ADD COLOR")
        self.current_label = tk.StringVar(value="1")
        self.current_color = tk.StringVar(value="#87CEFA")
        self.ship_no = tk.StringVar(value="")
        self.looking_txt = tk.StringVar(value="LOOKING TO FWD")
        self.rs_count = tk.StringVar(value="0")
        self.rd_per_rs = tk.StringVar(value="0")
        
        self.gang_vars = {g: tk.StringVar(value="0") for g in range(3, 10)}
        self.items: List[Item] = []
        self.editing_index: Optional[int] = None
        self.drag_start, self.drag_rect_id = None, None
        self.drag_start_right, self.drag_rect_id_right = None, None
        self.insert_pos = tk.StringVar(value="1")
        self.undo_stack = []

        self.rs_count.trace_add("write", self._recompute_all)
        self.rd_per_rs.trace_add("write", self._recompute_all)

        
        self._create_widgets()
        self.draw_all()
        self._recompute_all()
        self._update_insert_spin_range()

    def _create_widgets(self):
        outer = ttk.Frame(self); outer.pack(fill="both", expand=True)
        right = ttk.Frame(outer); right.pack(side="right", fill="y", padx=(10, 0))
        left = ttk.Frame(outer); left.pack(side="left", fill="both", expand=True)

        cfg = ttk.LabelFrame(right, text="RS / RD Panels", padding=10)
        cfg.pack(fill="x", pady=(0, 10))
        ttk.Label(cfg, text="RS Panels").grid(row=0, column=0, sticky="e", padx=5, pady=2)
        ttk.Spinbox(cfg, from_=0, to=999, textvariable=self.rs_count, width=8).grid(row=0, column=1, sticky="w", pady=2)
        ttk.Label(cfg, text="RD per RS").grid(row=0, column=2, sticky="e", padx=5, pady=2)
        ttk.Spinbox(cfg, from_=0, to=999, textvariable=self.rd_per_rs, width=8).grid(row=0, column=3, sticky="w", pady=2)

        # --- [GUI MOD] ---
        # (Even / Odd) 텍스트가 제거된 버전으로 복원
        summary_frame = ttk.LabelFrame(right, text="Live Summary", padding=10)
        summary_frame.pack(fill="both", expand=True, pady=(0, 10)) 

        self.grand_total_label = ttk.Label(summary_frame, text="Grand Total: 0", font=("Segoe UI", 9, "bold"))
        self.grand_total_label.pack(anchor="w", pady=(0, 5))

        alloc = ttk.Frame(summary_frame); alloc.pack(fill="both", expand=True)
        left_col = ttk.Frame(alloc); left_col.pack(side="left", fill="both", expand=True, padx=(0,5))
        ttk.Label(left_col, text="PORT RS").pack(anchor="w") # " (Even)" 제거
        self.txt_even = tk.Text(left_col, width=15, height=34, font=("Consolas", 10)); self.txt_even.pack(fill="both", expand=True); self.txt_even.configure(state="disabled")
        
        right_col = ttk.Frame(alloc); right_col.pack(side="left", fill="both", expand=True, padx=(5,0))
        ttk.Label(right_col, text="STBD RS").pack(anchor="w") # " (Odd)" 제거
        self.txt_odd = tk.Text(right_col, width=15, height=34, font=("Consolas", 10)); self.txt_odd.pack(fill="both", expand=True); self.txt_odd.configure(state="disabled")
        # --- [END GUI MOD] ---

        top = ttk.Frame(left); top.pack(fill="x", pady=(0, 10))
        ttk.Label(top, text="Ship No.").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        ttk.Entry(top, textvariable=self.ship_no, width=14).grid(row=0, column=1, sticky="w", padx=(0,12), pady=2)
        ttk.Label(top, text="Header Right").grid(row=0, column=2, sticky="e", padx=4, pady=2)
        ttk.Entry(top, textvariable=self.looking_txt, width=18).grid(row=0, column=3, sticky="w", padx=(0,12), pady=2)
        ttk.Label(top, text="Mode").grid(row=1, column=0, sticky="e", padx=4, pady=2)
        self.cmb_mode = ttk.Combobox(top, textvariable=self.paint_mode, values=("ADD COLOR", "ADD NUMBER", "ERASER", "SOCKET"), width=12, state="readonly")
        self.cmb_mode.grid(row=1, column=1, sticky="w", padx=(0,12), pady=2)
        ttk.Label(top, text="Number").grid(row=1, column=2, sticky="e", padx=4, pady=2)
        ttk.Entry(top, textvariable=self.current_label, width=10).grid(row=1, column=3, sticky="w", padx=(0,12), pady=2)
        ttk.Label(top, text="Color").grid(row=1, column=4, sticky="e", padx=4, pady=2)
        self.color_preview = tk.Label(top, text="   ", bg=self.current_color.get(), relief="groove", width=4)
        self.color_preview.grid(row=1, column=5, sticky="w", padx=(0,4), pady=2)
        ttk.Button(top, text="Pick…", command=self.pick_color).grid(row=1, column=6, sticky="w", padx=(2,12), pady=2)

        btn_row = ttk.Frame(left); btn_row.pack(fill="x", pady=5)
        ttk.Button(btn_row, text="Import…", command=self.import_from_excel).grid(row=0, column=0, padx=2, pady=2)
        ttk.Button(btn_row, text="Edit", command=self.edit_selected).grid(row=0, column=1, padx=2, pady=2)
        ttk.Button(btn_row, text="Save", command=self.save_edits).grid(row=0, column=2, padx=2, pady=2)
        ttk.Button(btn_row, text="Delete", command=self.delete_selected).grid(row=0, column=3, padx=2, pady=2)
        ttk.Button(btn_row, text="Auto Set", command=self.auto_set_groups).grid(row=0, column=4, padx=(12,2), pady=2)
        ttk.Button(btn_row, text="Undo", command=self.undo).grid(row=0, column=5, padx=2, pady=2)
        ttk.Button(btn_row, text="Clear All", command=self.clear_all).grid(row=0, column=6, padx=2, pady=2)
        ttk.Button(btn_row, text="Export…", command=self.export_excel).grid(row=0, column=7, padx=(12,2), pady=2)

        self.canvas = tk.Canvas(left, bg="white", highlightthickness=1, highlightbackground="#cccccc")
        self.canvas.pack(fill="both", expand=True, pady=5)
        self.canvas.bind("<Button-1>", self.on_press); self.canvas.bind("<B1-Motion>", self.on_drag); self.canvas.bind("<ButtonRelease-1>", self.on_release)
        self.canvas.bind("<Button-3>", self.on_press_right); self.canvas.bind("<B3-Motion>", self.on_drag_right); self.canvas.bind("<ButtonRelease-3>", self.on_release_right)
        self.canvas.bind("<Control-Button-1>", self.on_press_right); self.canvas.bind("<Control-B1-Motion>", self.on_drag_right); self.canvas.bind("<Control-ButtonRelease-1>", self.on_release_right)

        gang_row = ttk.Frame(left); gang_row.pack(fill="x", pady=5)
        ttk.Label(gang_row, text="Gang per Block").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        col = 1
        for g in range(3, 10):
            ttk.Label(gang_row, text=f"{g}").grid(row=0, column=col, sticky="e", padx=4, pady=2)
            ttk.Entry(gang_row, textvariable=self.gang_vars[g], width=5).grid(row=0, column=col+1, sticky="w", padx=(0,8), pady=2)
            col += 2

        bottom = ttk.Frame(left); bottom.pack(fill="x", pady=5)
        ttk.Label(bottom, text="Items (Blocks / Sections)").pack(anchor="w")
        self.items_list = tk.Listbox(bottom, height=8); self.items_list.pack(fill="x", expand=True)
        self.items_list.bind("<Double-Button-1>", lambda e: self.edit_selected())

        meta = ttk.LabelFrame(left, text="Block Meta", padding=10)
        meta.pack(fill="x", pady=5)
        self.meta_label_type = tk.StringVar(value="Hatch No")
        ttk.Label(meta, text="Label Type").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        ttk.Combobox(meta, textvariable=self.meta_label_type, values=["Hatch No", "Hold No"], width=10, state="readonly").grid(row=0, column=1, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="No.").grid(row=0, column=2, sticky="e", padx=8, pady=2)
        self.meta_no = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_no, width=10).grid(row=0, column=3, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="Bay").grid(row=1, column=0, sticky="e", padx=4, pady=2)
        self.meta_bay = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_bay, width=10).grid(row=1, column=1, sticky="w", padx=4, pady=2)
        ttk.Label(meta, text="Deck").grid(row=1, column=2, sticky="e", padx=8, pady=2)
        self.meta_deck = tk.StringVar(value="")
        ttk.Entry(meta, textvariable=self.meta_deck, width=12).grid(row=1, column=3, sticky="w", padx=4, pady=2)
        ttk.Button(meta, text="Apply to Selected", command=self.apply_meta_to_selected).grid(row=0, column=4, rowspan=2, sticky="nsw", padx=(12,4), pady=2)

        sec = ttk.LabelFrame(left, text="Insert Section", padding=10)
        sec.pack(fill="x", pady=5)
        ttk.Label(sec, text="삽입 위치(1-기준)").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        self.pos_spin = ttk.Spinbox(sec, from_=1, to=1, textvariable=self.insert_pos, width=6)
        self.pos_spin.grid(row=0, column=1, sticky="w", padx=4, pady=2)
        ttk.Button(sec, text="Insert ACCOMMODATION", command=lambda: self.insert_section_at("ACCOMMODATION")).grid(row=0, column=2, padx=(12,4), pady=2)
        ttk.Button(sec, text="Insert E/R CASING", command=lambda: self.insert_section_at("E/R CASING")).grid(row=0, column=3, padx=4, pady=2)

    def _save_state_for_undo(self):
        state = {
            'items': copy.deepcopy(self.items),
            'editing_index': self.editing_index,
            'canvas_data': (copy.deepcopy(self.cell_colors), copy.deepcopy(self.cell_numbers), copy.deepcopy(self.sockets))
        }
        self.undo_stack.append(state)
        if len(self.undo_stack) > 10:  # Keep last 10 states
            self.undo_stack.pop(0)

    def undo(self):
        if not self.undo_stack:
            messagebox.showinfo("Undo", "더 이상 되돌릴 작업이 없습니다.")
            return

        state = self.undo_stack.pop()
        self.items = state['items']
        self.editing_index = state['editing_index']
        self.cell_colors, self.cell_numbers, self.sockets = state['canvas_data']

        if self.editing_index is not None:
            self.edit_selected() # Reload editor if it was active
        else:
            self.draw_all()

        self.refresh_list()
        self._recompute_all()

    def clear_all(self):
        if messagebox.askyesno("Clear All", "모든 블럭과 작업 내용을 정말로 초기화하시겠습니까?"):
            self._save_state_for_undo()
            self.items.clear()
            self.editing_index = None
            self.clear_canvas()
            self.refresh_list()
            self.winfo_toplevel().title("Reefer Layout")

    def _recompute_all(self, *args):
        self._update_allocation_display()

    # --- [GUI MOD] ---
    # _update_allocation_display (Port/Stbd 텍스트 박스 업데이트)
    def _update_allocation_display(self):
        try:
            rs_total = int(self.rs_count.get() or 0)
            rpr = int(self.rd_per_rs.get() or 0)
        except(ValueError, TypeError):
            rs_total = 0
            rpr = 0

        even_rs = [i for i in range(1, rs_total+1) if i % 2 == 0]
        odd_rs  = [i for i in range(1, rs_total+1) if i % 2 == 1]

        rd_counts = _collect_rd_counts(self.items)
   
        grand_total = sum(rd_counts.values())
        # [BUG FIX] Grand Total이 실제 값을 반영하도록 수정
        self.grand_total_label.config(text=f"Grand Total: {grand_total}")

        # Port/Stbd 텍스트 박스 업데이트 로직
        for txt_widget, indices in [(self.txt_even, even_rs), (self.txt_odd, odd_rs)]:
            content = _build_rs_summary(indices, rd_counts, rpr)
            txt_widget.config(state="normal")
            txt_widget.delete("1.0", tk.END)
            txt_widget.insert(tk.END, content)
            txt_widget.config(state="disabled")
    # --- [END GUI MOD] ---

    def pick_color(self):
        _, hx = colorchooser.askcolor(color=self.current_color.get(), title="Pick Color")
        if hx:
            self.current_color.set(hx)
            self.color_preview.config(bg=hx)

    def clear_canvas(self):
        self.cell_colors.clear(); self.cell_numbers.clear(); self.sockets.clear()
        self.draw_all()

    def cell_to_xy(self, r, c):
        x1, y1 = (c - 1) * self.cell_px + 1, (r - 1) * self.cell_px + 1
        return x1, y1, x1 + self.cell_px, y1 + self.cell_px

    def xy_to_cell(self, x, y):
        c, r = int((x - 1) // self.cell_px) + 1, int((y - 1) // self.cell_px) + 1
        return (r, c) if 1 <= r <= self.rows and 1 <= c <= self.cols else None

    def draw_all(self):
        self.canvas.delete("all")
        self.canvas.config(width=self.cols * self.cell_px + 2, height=self.rows * self.cell_px + 2)
        for r in range(1, self.rows + 1):
            for c in range(1, self.cols + 1):
                x1, y1, x2, y2 = self.cell_to_xy(r, c)
                self.canvas.create_rectangle(x1, y1, x2, y2, fill=self.cell_colors.get((r, c), "#FFFFFF"), outline="#CCCCCC")
        for r, c in self.sockets:
            x1, y1, x2, y2 = self.cell_to_xy(r, c)
            self.canvas.create_rectangle(x1 + 1, y1 + 1, x2 - 1, y2 - 1, outline="#FF0000", width=2)
        for (r, c), val in self.cell_numbers.items():
            x, y = (c - 0.5) * self.cell_px, (r - 0.5) * self.cell_px
            self.canvas.create_text(x, y, text=str(val), font=("Arial", 8))

    def on_press(self, e):
        self._save_state_for_undo()
        self.drag_start = self.xy_to_cell(e.x, e.y)
        self.update_drag_rect(e, left_click=True)

    def on_drag(self, e):
        self.update_drag_rect(e, left_click=True)

    def on_release(self, e):
        if self.drag_rect_id:
            self.canvas.delete(self.drag_rect_id)
            self.drag_rect_id = None
        if not self.drag_start: return
        end_cell = self.xy_to_cell(e.x, e.y) or self.drag_start
        r1, c1 = self.drag_start
        r2, c2 = end_cell
        mode = self.paint_mode.get()
        for r in range(min(r1, r2), max(r1, r2) + 1):
            for c in range(min(c1, c2), max(c1, c2) + 1):
                pos = (r, c)
                if mode == "ADD COLOR": self.cell_colors[pos] = self.current_color.get()
                elif mode == "ADD NUMBER": self.cell_numbers[pos] = parse_number_like(self.current_label.get())
                elif mode == "ERASER": self.cell_colors.pop(pos, None); self.cell_numbers.pop(pos, None); self.sockets.discard(pos)
                elif mode == "SOCKET": self.sockets.add(pos)
        self.drag_start = None
        self.draw_all()
        self._recompute_all()

    def on_press_right(self, e):
        self._save_state_for_undo()
        self.drag_start_right = self.xy_to_cell(e.x, e.y)
        self.update_drag_rect(e, left_click=False)

    def on_drag_right(self, e):
        self.update_drag_rect(e, left_click=False)

    def on_release_right(self, e):
        if self.drag_rect_id_right:
            self.canvas.delete(self.drag_rect_id_right)
            self.drag_rect_id_right = None
        if not self.drag_start_right: return
        end_cell = self.xy_to_cell(e.x, e.y) or self.drag_start_right
        r1, c1 = self.drag_start_right
        r2, c2 = end_cell
        for r in range(min(r1, r2), max(r1, r2) + 1):
            for c in range(min(c1, c2), max(c1, c2) + 1):
                pos = (r, c)
                mode = self.paint_mode.get()
                if mode == "ADD COLOR": self.cell_colors.pop(pos, None)
                elif mode == "ADD NUMBER": self.cell_numbers.pop(pos, None)
                elif mode == "SOCKET": self.sockets.discard(pos)
        self.drag_start_right = None
        self.draw_all()
        self._recompute_all()

    def update_drag_rect(self, e, left_click=True):
        start = self.drag_start if left_click else self.drag_start_right
        if not start: return
        cell = self.xy_to_cell(e.x, e.y)
        if not cell: return
        rect_id = self.drag_rect_id if left_click else self.drag_rect_id_right
        if rect_id: self.canvas.delete(rect_id)
        r1, c1 = start
        r2, c2 = cell
        x1, y1, _, _ = self.cell_to_xy(min(r1, r2), min(c1, c2))
        _, _, x2, y2 = self.cell_to_xy(max(r1, r2), max(c1, c2))
        outline_color = "#3B82F6" if left_click else "#EF4444"
        new_rect_id = self.canvas.create_rectangle(x1, y1, x2, y2, outline=outline_color, width=2, dash=(4, 2))
        if left_click: self.drag_rect_id = new_rect_id
        else: self.drag_rect_id_right = new_rect_id

    def refresh_list(self):
        sel = self.items_list.curselection()
        self.items_list.delete(0, tk.END)
        for i, it in enumerate(self.items, 1):
            self.items_list.insert(tk.END, self.item_label(it, i))
        if sel: self.items_list.selection_set(sel[0])
        self._update_insert_spin_range()
        self._recompute_all()

    def _update_insert_spin_range(self):
        total = len(self.items) + 1
        self.pos_spin.config(to=total)
        sel = self.items_list.curselection()
        self.insert_pos.set(str(sel[0] + 1 if sel else total))

    def item_label(self, it, idx):
        if isinstance(it, SectionHeader): return f"[Section] {it.title}"
        b: Block = it
        label = f"Hatch:{b.hatch}" if b.hatch else (f"Hold:{b.hold}" if b.hold else "-")
        return f"Block {idx} — {b.rows}x{b.cols} | {label} Bay:{b.bay or '-'} Deck:{b.deck or '-'} | Nums:{len(b.cell_numbers)}"

    def _write_gang_counts(self, counts):
        for g in range(3, 10): self.gang_vars[g].set(str(counts.get(g, 0)))

    # --- 수정된 함수 ---
    def edit_selected(self, event=None):
        sel = self.items_list.curselection()
        if not sel:
            messagebox.showinfo("Info", "편집할 블럭을 선택하세요.")
            return
        idx = sel[0]
        it = self.items[idx]
        if isinstance(it, SectionHeader): return

        self.editing_index = idx
        b: Block = it
        self.rows, self.cols = b.rows, b.cols
        self.cell_colors, self.cell_numbers, self.sockets = dict(b.cell_colors), dict(b.cell_numbers), set(b.sockets)
        self._write_gang_counts(b.gang_counts)
        
        # --- 블록 행 수에 따라 Hatch/Hold 자동 선택 ---
        if b.rows >= 6:
            self.meta_label_type.set("Hold No")
            self.meta_no.set(b.hold)
        else:
            self.meta_label_type.set("Hatch No")
            self.meta_no.set(b.hatch)
        # -----------------------------------------
            
        self.meta_bay.set(b.bay); self.meta_deck.set(b.deck)
        self.draw_all()
        self.winfo_toplevel().title("Reefer Layout [EDITING]")

    def save_edits(self):
        self._save_state_for_undo()
        if self.editing_index is None: return
        b: Block = self.items[self.editing_index]
        b.cell_colors, b.cell_numbers, b.sockets = dict(self.cell_colors), dict(self.cell_numbers), set(self.sockets)
        b.gang_counts = {g: int(self.gang_vars[g].get() or 0) for g in range(3, 10)}
        self.refresh_list()
        self.editing_index = None
        self.winfo_toplevel().title("Reefer Layout")
        messagebox.showinfo("Saved", "블럭 수정이 저장되었습니다.")

    def delete_selected(self):
        sel = self.items_list.curselection()
        if sel and messagebox.askyesno("Confirm", "정말로 선택한 아이템을 삭제하시겠습니까?"):
            self._save_state_for_undo()
            del self.items[sel[0]]
            self.refresh_list()

    def apply_meta_to_selected(self):
        sel = self.items_list.curselection()
        if not sel: return
        self._save_state_for_undo()
        b: Block = self.items[sel[0]]
        if self.meta_label_type.get() == "Hold No": b.hold, b.hatch = self.meta_no.get(), ""
        else: b.hatch, b.hold = self.meta_no.get(), ""
        b.bay, b.deck = self.meta_bay.get(), self.meta_deck.get()
        self.refresh_list()

    def insert_section_at(self, title):
        self._save_state_for_undo()
        try: pos = int(self.insert_pos.get()) - 1
        except (ValueError, TypeError): pos = len(self.items)
        self.items.insert(pos, SectionHeader(title=title))
        self.refresh_list()

    # --- 수정된 함수 ---
    def import_from_excel(self):
        path = filedialog.askopenfilename(filetypes=[("Excel", "*.xlsx *.xlsm")])
        if not path: return
        self._save_state_for_undo()
        try:
            wb = load_workbook(path, data_only=True)
            ws = wb.active
        except Exception as e:
            messagebox.showerror("Error", f"파일 열기 실패:\n{e}")
            return

        added, skipped = 0, 0
        for row in ws.iter_rows(min_row=1, values_only=True):
            if not row or len(row) < 2 or row[0] is None or row[1] is None: continue
            try:
                values = [int(p.strip()) for p in str(row[1]).replace("，", ",").split(",") if p.strip()]
                if not values: raise ValueError
                rows, cols = len(values), max(values)
          
                # --- 블록 생성 시 Hatch/Hold 자동 할당 ---
                b = Block(rows=rows, cols=cols)
                if rows >= 6:
                    b.hold = str(row[0]).strip() # 엑셀 첫번째 열을 기본 번호로 사용
                else:
                    b.hatch = str(row[0]).strip() # 엑셀 첫번째 열을 기본 번호로 사용
                # ---------------------------------------
                    
                for r_idx, cnt in enumerate(values, 1):
                    start_c = 1 + (cols - cnt) // 2
                    for k in range(cnt): b.cell_colors[(r_idx, start_c + k)] = "#EEEEEE"
                self.items.append(b)
                added += 1
            except:
                skipped += 1
        self.refresh_list()
        messagebox.showinfo("Import", f"완료: {added}개 블럭 추가, {skipped}행 무시")

    def export_excel(self):
        if not self.items: return
        path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")])
        if path:
            try:
                write_excel(
                    self.items, 
                    path, 
                    self.ship_no.get(), 
                    self.looking_txt.get(),
                    self.rs_count.get(),
                    self.rd_per_rs.get()
                )
                messagebox.showinfo("Exported", f"파일 저장 완료:\n{path}")
            except Exception as e:
                messagebox.showerror("Error", f"저장 실패:\n{e}")

    # =================================================================
    # Auto Set 그룹 (메인 로직)
    # =================================================================
    # --- [MODIFIED] V10 (목표량 기반 순차 할당 + 후-채우기) 로직 ---
    def auto_set_groups(self):
        self._save_state_for_undo()
        sel = self.items_list.curselection()
        targets = [self.items[sel[0]]] if sel and isinstance(self.items[sel[0]], Block) else [it for it in self.items if isinstance(it, Block)]
        if not targets:
            messagebox.showinfo("Auto Set", "대상 블럭이 없습니다.")
            return

        cap = simpledialog.askinteger("Auto Set", "RD panel 당 최대 컨테이너 수", minvalue=4, maxvalue=9999, parent=self)
        if cap is None: return 

        try:
            rs_total = int(self.rs_count.get() or 0)
            rpr = int(self.rd_per_rs.get() or 0)
        except(ValueError, TypeError):
            rs_total, rpr = 0, 0
            
        even_list, odd_list = _build_rd_queues(rs_total, rpr)

        # --- PASS 1: "배치하기" (모양 찾기 및 총계 계산) ---
        
        all_left_placements = []
        all_right_placements = []
        total_left_cells = 0
        total_right_cells = 0
        any_failure = False

        for b in targets:
            b.cell_numbers.clear() 
            b.gang_counts = {g: 0 for g in range(3, 10)}

            unfilled_cells = {p for p, color in b.cell_colors.items()}
            
            center_col = (b.cols + 1) / 2.0
            left_active = {p for p in unfilled_cells if p[1] < center_col}
            right_active = {p for p in unfilled_cells if p[1] > center_col}
            center_cells = {p for p in unfilled_cells if p[1] == center_col}

            if len(left_active) <= len(right_active):
                left_active.update(center_cells)
            else:
                right_active.update(center_cells)

            placements = [] 
            success = False
            if b.rows >= 6:
                success = self._solve_line_tiling(b, left_active, "LEFT", placements) and \
                          self._solve_line_tiling(b, right_active, "RIGHT", placements)
            else:
                right_placements, left_placements = [], []
                if self._solve_tiling_recursive(b, right_active, "RIGHT", right_placements):
                    if self._solve_tiling_recursive(b, left_active, "LEFT", left_placements):
                        placements = right_placements + left_placements
                        success = True

            if not success:
                messagebox.showerror("배치 실패", f"블록 {b.hatch or b.hold or '(번호 없음)'}에서 빈 칸 없이 모든 공간을 채우는 조합을 찾지 못했습니다.\n블록 모양을 확인해주세요.")
                any_failure = True
                continue

            # 모양(Placement) 정렬 및 집계
            left_placements_b = [p for p in placements if p['side'] == 'LEFT']
            right_placements_b = [p for p in placements if p['side'] == 'RIGHT']

            left_placements_b.sort(key=lambda p: (min(r for r,c in p['cells']), min(c for r,c in p['cells'])))
            right_placements_b.sort(key=lambda p: (min(r for r,c in p['cells']), -max(c for r,c in p['cells'])))

            for p in left_placements_b:
                all_left_placements.append( (b, p) ) 
                total_left_cells += p['size']
                
            for p in right_placements_b:
                all_right_placements.append( (b, p) ) 
                total_right_cells += p['size']

        # --- END PASS 1 ---

        if any_failure:
            return

        # --- PASS 2: "숫자 배당하기" (목표량 계산 및 순차 할당 + 후-채우기) ---

        # 2a. PORT/Even (Left) 목표량 및 실제 남은 용량 초기화
        target_counts_even = {} 
        rd_remaining_even = {rd: cap for rd in even_list} 
        total_even_rds = len(even_list)
        if total_even_rds > 0 and total_left_cells > 0:
            avg_cap_even = total_left_cells // total_even_rds 
            rem_even = total_left_cells % total_even_rds     
            for i, rd in enumerate(even_list):
                target_counts_even[rd] = avg_cap_even + (1 if i < rem_even else 0)
        
        # 2b. STBD/Odd (Right) 목표량 및 실제 남은 용량 초기화
        target_counts_odd = {} 
        rd_remaining_odd = {rd: cap for rd in odd_list} 
        total_odd_rds = len(odd_list)
        if total_odd_rds > 0 and total_right_cells > 0:
            avg_cap_odd = total_right_cells // total_odd_rds 
            rem_odd = total_right_cells % total_odd_rds     
            for i, rd in enumerate(odd_list):
                target_counts_odd[rd] = avg_cap_odd + (1 if i < rem_odd else 0)

        # 2c. PORT/Even (Left) 목표량 기반 순차 배당 (+ 후-채우기)
        cur_even = [0] 
        for (b, p) in all_left_placements: 
            need = p['size'] 
            cells = p['cells'] 
            
            assigned_rd = self._rd_take_v10(need, target_counts_even, rd_remaining_even, even_list, cur_even)
            
            if assigned_rd is not None:
                color = self._pick_color(cells, b)
                for cell in cells:
                    b.cell_numbers[cell] = assigned_rd
                    b.cell_colors[cell] = color
                b.gang_counts[need] = b.gang_counts.get(need, 0) + 1
            else:
                 print(f"INFO: Could not assign LEFT placement size {need}. All even RDs might be full or cannot accommodate.")

        # 2d. STBD/Odd (Right) 목표량 기반 순차 배당 (+ 후-채우기)
        cur_odd = [0] 
        for (b, p) in all_right_placements: 
            need = p['size'] 
            cells = p['cells'] 

            assigned_rd = self._rd_take_v10(need, target_counts_odd, rd_remaining_odd, odd_list, cur_odd)
            
            if assigned_rd is not None:
                color = self._pick_color(cells, b)
                for cell in cells:
                    b.cell_numbers[cell] = assigned_rd
                    b.cell_colors[cell] = color
                b.gang_counts[need] = b.gang_counts.get(need, 0) + 1
            else:
                 print(f"INFO: Could not assign RIGHT placement size {need}. All odd RDs might be full or cannot accommodate.")

        # --- END PASS 2 ---
        
        if self.editing_index is not None: self.edit_selected() 
        self.refresh_list() 
        self._recompute_all() 
        messagebox.showinfo("Auto Set", "자동 배치 완료 (V10: 목표량+후-채우기 적용)")
    # --- [END MODIFIED] ---


    # --- 6행 이상 블록을 위한 1줄 배치 전용 함수 ---
    def _solve_line_tiling(self, b: Block, side_active: Set[Cell], side: str, placements: List[Dict]) -> bool:
        def partition(length: int) -> Optional[List[int]]:
            sizes = sorted([s for s in SHAPE_LIBRARY.keys() if s <= length], reverse=True)
            memo = {}
            def find(rem_len):
                if rem_len == 0: return []
                if rem_len < 4 : return None
                if rem_len in memo: return memo[rem_len]
                for size in sizes:
                    if size <= rem_len:
                        res = find(rem_len - size)
                        if res is not None:
                            memo[rem_len] = [size] + res
                            return memo[rem_len]
                memo[rem_len] = None
                return None
            return find(length)

        rows = sorted(list({r for r, c in side_active}))
        for r in rows:
            cols_in_row = sorted([c for r_c, c in side_active if r_c == r])
            if not cols_in_row: continue
            spans = []
            start = cols_in_row[0]
            for i in range(1, len(cols_in_row)):
                if cols_in_row[i] != cols_in_row[i-1] + 1:
                    spans.append((start, cols_in_row[i-1]))
                    start = cols_in_row[i]
            spans.append((start, cols_in_row[-1]))
            for start_col, end_col in spans:
                span_len = end_col - start_col + 1
                pieces = partition(span_len)
                if pieces is None: return False
                ptr = start_col
                for size in pieces:
                    cells = {(r, c) for c in range(ptr, ptr + size)}
                    placements.append({'size': size, 'cells': cells, 'side': side})
                    ptr += size
        return True

    # --- 5행 이하 블록을 위한 백트래킹 함수 ---
    def _solve_tiling_recursive(self, b: Block, unfilled: Set[Cell], side: str, placements: List[Dict]) -> bool:
        if not unfilled:
            return True

        is_left = (side == "LEFT")
        start_cell = min(unfilled, key=lambda p: (p[0], p[1] if is_left else -p[1]))

        priority_sizes = [9, 7, 8, 6, 5, 4]
        
        # 1. 비-라인(다차원) 형태 먼저 시도
        for size in priority_sizes:
            for shape_pattern in SHAPE_LIBRARY.get(size, []):
                shape_height = max(r_off for r_off, c_off in shape_pattern) + 1
                shape_width = max(c_off for r_off, c_off in shape_pattern) + 1
                if shape_height == 1 or shape_width == 1:
                    continue 

                group_cells = {(start_cell[0] + r_off, start_cell[1] + (c_off if is_left else -c_off))
                               for r_off, c_off in shape_pattern}

                if group_cells.issubset(unfilled):
                    placements.append({'size': size, 'cells': group_cells, 'side': side})
                    if self._solve_tiling_recursive(b, unfilled - group_cells, side, placements):
                        return True
                    placements.pop()

        # 2. 다차원 형태로 실패 시, 1줄 형태를 시도
        for size in priority_sizes:
            for shape_pattern in SHAPE_LIBRARY.get(size, []):
                shape_height = max(r_off for r_off, c_off in shape_pattern) + 1
                shape_width = max(c_off for r_off, c_off in shape_pattern) + 1
                if not (shape_height == 1 or shape_width == 1):
                    continue

                group_cells = {(start_cell[0] + r_off, start_cell[1] + (c_off if is_left else -c_off))
                                       for r_off, c_off in shape_pattern}
                if not group_cells.issubset(unfilled): 
                    continue

                remaining_unfilled = unfilled - group_cells
                is_isolated = True
                for r_cell, c_cell in group_cells:
                    if (r_cell - 1, c_cell) in remaining_unfilled or (r_cell + 1, c_cell) in remaining_unfilled:
                        is_isolated = False
                        break
                
                if not is_isolated:
                    continue

                placements.append({'size': size, 'cells': group_cells, 'side': side})
                if self._solve_tiling_recursive(b, unfilled - group_cells, side, placements):
                    return True
                placements.pop()

        return False

    # --- [NEW] V10 할당 로직 ---
    def _rd_take_v10(self, need, target_counts, rd_remaining, rds, cursor):
        """
        V10: 목표량 기반 순차 할당 + 후-채우기 (Target-Guided Sequential Fill + Fallback)
        1. 현재 커서부터 순차적으로 RD를 확인하며 아래 조건을 만족하는 첫 RD에 할당:
           - 실제 남은 용량(rd_remaining) >= need
           - 남은 목표량(target_counts) > 0
           - 할당 성공 시 커서는 **그대로** 유지.
        2. 만약 1번에서 할당할 RD를 찾지 못했다면 (커서~끝까지 확인 후),
           **처음(인덱스 0)부터 다시** 순회하며 아래 조건을 만족하는 첫 RD에 할당 (후-채우기):
           - 실제 남은 용량(rd_remaining) >= need (목표량 무시)
           - 할당 성공 시 커서를 해당 RD 인덱스로 **이동**.
        3. 1, 2 모두 실패하면 None 반환.
        """
        n = len(rds)
        if n == 0: return None
        
        # --- 1. 목표량 기반 순차 할당 시도 (현재 커서부터 끝까지) ---
        current_idx = cursor[0] 
        while current_idx < n:
            current_rd = rds[current_idx]
            
            can_fit = rd_remaining.get(current_rd, 0) >= need
            below_target = target_counts.get(current_rd, 0) > 0 
            
            if can_fit and below_target:
                rd_remaining[current_rd] -= need
                target_counts[current_rd] = target_counts.get(current_rd, 0) - need 
                cursor[0] = current_idx # 커서를 현재 위치로 갱신 (다음 RD로 넘어가지 않음)
                return current_rd
                
            current_idx += 1 # 다음 RD로 이동
            
        # --- 2. 후-채우기: 목표량 무시하고 물리적으로 가능한 첫 RD에 할당 (처음부터 다시 순회) ---
        for i in range(n): 
            check_idx = i 
            check_rd = rds[check_idx]
            if rd_remaining.get(check_rd, 0) >= need:
                rd_remaining[check_rd] -= need
                target_counts[check_rd] = target_counts.get(check_rd, 0) - need 
                cursor[0] = check_idx # 커서를 할당한 위치로 이동
                return check_rd
                
        # --- 3. 후-채우기까지 실패 (정말로 공간 없음) ---
        return None
    # --- [END NEW] ---


    def _pick_color(self, cells, b):
        palette = ["#87CEFA","#F6BD60","#F28482","#84A59D","#B8E1DD","#E5989B","#BFD200","#FFBE0B","#9B5DE5"]
        adj_colors = set()
        for r, c in cells:
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: 
                adj_cell = (r + dr, c + dc)
                if adj_cell in b.cell_colors: 
                    adj_colors.add(b.cell_colors[adj_cell]) 
        
        for color in palette:
            if color not in adj_colors:
                return color
        return random.choice(palette)


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Reefer Layout")
        try:
            from ctypes import windll; windll.shcore.SetProcessDpiAwareness(1)
        except: pass
        self.geometry("1400x950") 
        self.minsize(1200, 800) 
        GridCanvas(self) 

if __name__ == '__main__':
    app = App() 
    app.mainloop()
